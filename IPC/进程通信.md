 说明

本目录下总结的是进程间通信 IPC 的相关内容

相关链接：

[linux基础——linux进程间通信（IPC）机制总结](https://blog.csdn.net/a987073381/article/details/52006729)



[Linux 下的进程间通信：套接字和信号 | Linux 中国](https://mp.weixin.qq.com/s/UuewKXGTS57YmDrUeg_mJw)



[Linux 下的进程间通信：共享存储 | Linux 中国](https://mp.weixin.qq.com/s/iMQvX-ueb8tmvXly_26d3A)



[Linux 下的进程间通信：使用管道和消息队列 | Linux 中国](https://mp.weixin.qq.com/s/y_SZSSnFwTIH4fdEexlq6w)



#   概念



## 进程

全文脉络思维导图如下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9x0wgXBMLYGsibCWVjiaCOn0fHO06Cfj4jYuOEPWAUrKHJDJID222B328A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###   进程与线程的简单解释

进程（Process）和线程（Thread）是操作系统的基本概念，但是它们比较抽象，不容易掌握。以下这个解释出自阮一峰老师的博客（http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html），虽然**「不是非常严谨，但是足够形象」**，看完之后能对进程和线程有个非常直观的印象，这样也方便理解后文。

① 计算机的核心是 CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9xicmG6b8LWelyBbHPCexMQAjyrxlmbicQQBPM9k85s9P6mgnMGB9TvXYw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

② **「假定工厂的电力有限，一次只能供给一个车间使用」**。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个 CPU 一次只能运行一个任务。

③ 进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。任一时刻，CPU 总是运行一个进程，其他进程处于非运行状态。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9xb5m6WEticW2ryEoqicHCFrrUVHH0APZiblkhJ6Hd6x1EFROjBYCj7o3wg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

④ 一个车间里，可以有很多工人。他们协同完成一个任务。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9xl0QhD4F48lsq1mVdK9DaAauozRLMg7cGUlu5RF4VrLDdB56YpPibCqA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

⑤ 线程就好比车间里的工人。一个进程可以包括多个线程。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9xDCI3aZDibXyldQrAKJggsUF70KXKHHwfTjNdYRwrUd7LHJ63Hz8qTeA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

⑥ 车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9xSutVmJvVke0rq1H5Flb4CgdGtFMbnyAaYby26xRkyagAKjMdrcQibCA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

⑦ 可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9xQY2mZxz5UJXfBvtB8xznKa3d2SKM6S4WxthT1ZDlRotffdrHFkjdOQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

⑧ 一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。

⑨ 还有些房间，可以同时容纳 n 个人，比如厨房。也就是说，如果人数大于 n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。

⑩ 这时的解决方法，就是在门口挂 n 把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做 "信号量"（Semaphore），用来保证多个线程不会互相冲突。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9xO1CTXibJdxQF8R90O0aSQXib71MS1xemPZedtB0lej1bgCN2CiaX6aNZg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

不难看出，互斥锁 Mutex 是信号量 semaphore 的一种特殊情况（n = 1时）。也就是说，完全可以用后者替代前者。但是，因为 Mutex 较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。

###  什么是进程

结合上文的简单解释，下面给出进程的科学定义：**「进程是程序在某个数据集合上的一次运行活动，也是操作系统进行资源分配和保护的基本单位」**。

通俗来说，**「进程就是程序的一次执行过程」**，程序是静态的，它作为系统中的一种资源是永远存在的。而进程是动态的，它是动态的产生，变化和消亡的，拥有其自己的生命周期。

举个例子：同时挂三个 QQ 号，它们就对应三个 QQ 进程，退出一个就会杀死一个对应的进程。但是，就算你把这三个 QQ 全都退出了，QQ 这个程序死亡了吗？显然没有。

进程不仅包含正在运行的程序实体，并且包括这个运行的程序中占据的所有系统资源，比如说 CPU、内存、网络资源等。很多小伙伴在回答进程的概念的时候，往往只会说它是一个运行的实体，而会忽略掉进程所占据的资源。比如说，同样一个程序，同一时刻被两次运行了，那么他们就是两个独立的进程。

###  进程的组成

进程主要由三个部分组成：

1）**「进程控制块 PCB」**。包含如下几个部分：

- 进程描述信息
- 进程控制和管理信息
- 资源分配清单
- CPU 相关信息

2）**「数据段」**。即进程运行过程中各种数据（比如程序中定义的变量）

3）**「程序段」**。就是程序的代码（指令序列）

举个例子：同时挂三个 QQ 号，会对应三个 QQ 进程，它们的 PCB、数据段各不相同，但程序段的内容都是相同的 （都是运行着相同的 QQ 程序）

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9xTwjPiaGDH9nXbyQpAhU3tD0ZPVgmsVUbwIFOBxLOibwIv366rhS4yhDA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

PCB 是提供给操作系统用的，而程序段、数据段是给进程自己用的。

> 进程控制块 PCB

每个进程有且仅有一个进程控制块（Process Control Block，PCB），或称进程描述符，它是**「进程存在的唯一标识」**，是**「操作系统用来记录和刻画进程状态及环境信息的数据结构」**，也是操作系统掌握进程的唯一资料结构和管理进程的主要依据。所以说 PCB 是提供给操作系统使用的。

通俗的解释：操作系统需要对各个进程进行管理，但凡管理时所需要的信息，都会被放在 PCB 中，**「PCB 是进程存在的唯一标志」**。创建进程和撤销进程等都是指对 PCB 的操作，当进程被创建时，操作系统为其创建 PCB，当进程结束时，会回收其 PCB。

一般来说，PCB 会包含如下四类信息：

1）**「进程描述信息」**：用来让操作系统区分各个进程

- 当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的 “身份证号”— **「PID」**（ProcessID，进程 ID）
- 另外，进程描述信息还包含进程所属的用户 ID（**「UID」**）

2）**「进程控制和管理信息」**：记录进程的运行情况。比如 CPU 的使用时间、磁盘使用情况、网络流量使用情况等。

3）**「资源分配清单」**：记录给进程分配了哪些资源。比如分配了多少内存、正在使用哪些 I/O 设备、正在使用哪些文件等。

4）**「CPU 相关信息」**：进程在让出 CPU 时，必须保存该进程在 CPU 中的各种信息，比如各种寄存器的值。用于实现进程切换，确保这个进程再次运行的时候恢复 CPU 现场，从断点处继续执行。这就是所谓的**「保存现场信息」**。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9xBfLA3GdgUB9j2Xxh1WQkYXgqTZ14EtGwavicMrfgU42NyRcUv1nEq5A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

###  进程的状态

尽管每一个进程都是独立的实体，有其自己的 PCB 和内部状态，但是进程之间经常需要相互作用。一个进程的输出结果可能是另一个进程的输入。假设进程 A 的输入依赖进程 B 的输出，那么在进程 B 的输出结果没有出来之前，进程 A 就无法执行，它就会被阻塞。这就是进程的阻塞态。

经典的进程三态模型如下：

- **「运行态」**（running）：进程占有 CPU 正在运行。
- **「就绪态」**（ready）：进程具备运行条件，等待系统分配 CPU 以便运行。
- **「阻塞态」** / 等待态（wait）：进程不具备运行条件，正在等待某个事件的完成。

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9xiaoKuicdsjCCD5Mibu4Rqp4JWewDyiaAqJ4Hf5nKBbPIib71LVqia0tHbgMA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

上图中的时间片用完，可以这样理解：

进程是并发执行的嘛，宏观上在一段时间内能同时运行多个程序，但其实微观上是交替发生的。也就是说 CPU 一般不会让一个进程一次性执行完，为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。某个进程的时间片用完后这个进程就会进入就绪态，而其他被分配到时间片的进程就会进入运行态。这个处于就绪态的进程就需要等待进程调度程序的下一次调度，为其分配 CPU 时间片后才能再次恢复运行。

需要注意的是：**「阻塞态是由于缺少需要的资源从而由运行态转换而来，但是该资源不包括 CPU 时间片，缺少 CPU 时间片会从运行态转换为就绪态」**。

很多系统中都增加了新建态（new）和终止态（exit），形成**「五态模型」**：

- **「新建态」**（new）：进程正在被创建时的状态
- **「终止态」**（exit）：进程正在从系统中消失时的状态

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9xM83HUYMBulpXicIj1JFVuueKv5pA1gDQFOZ4gAzbBLhdpujNaic8QGlQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

从上图可以发现，**「只有就绪态和运行态可以相互转换，其它的都是单向转换」**。

这些不同状态的进程操作系统是如何进行管理的呢？上文说过，PCB 是提供给操作系统使用的，是操作系统管理进程的主要依据。没错，操作就是通过 PCB 来管理这些拥有不同状态的进程的。

进程的 PCB 会通过某种方式组织起来，一般来说，操作系统会把处于同一状态的所有进程的 PCB 链接在一起，这种数据结构就称为**「进程队列」**（Process Queue）。

### 进程控制

所谓进程控制就是对系统中的所有进程实施有效的管理，**「实现进程状态转换」**功能。包括创建进程、阻塞进程、唤醒进程、终止进程等，这些功能均由**「原语」**来实现，操作系统通过原语来完成进程原理，包括进程的同步和互斥、进程的通信和管理。

**「什么是原语」**？原语是一种特殊的程序，它的执行具有**「原子性」**。也就是说，这段程序的运行必须一气呵成，不可中断。原语是操作系统内核里的一段程序：

![图片](https://mmbiz.qpic.cn/mmbiz_png/PocakShgoGGwkgiaicj3v8lMl3EEUzpb9x3zWqAWibnicaXaj5btBEG4NUUs7RZB6o8fdrlgaq9fbUxmqR67YDADpA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

思考一下：为什么进程控制（进程状态转换）的过程要一气呵成，不可中断？

答：如果进程状态转换的过程不能一气呵成，就有可能导致操作系统中的某些关键数据结构信息不统一，这会影响操作系统进行别的管理工作。

#### 进程的创建

操作系统初始启动时会创建承担系统资源分配和控制管理的一些系统进程，同时还会创建一个所有用户进程的祖先，其他用户进程是在应用程序运行时创建的。

操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程。同时，终止父进程时同时也会终止其所有的子进程。

创建进程的过程，也就是**「创建原语」**包含的内容如下：

- 在进程列表中增加一项，从 PCB 池中申请一个空闲的 PCB（PCB 是有限的，若申请失败则创建失败），为新进程分配一个唯一的进程标识符；
- 为新进程分配地址空间，由进程管理程序确定加载至进程地址空间中的程序；
- 为新进程分配各种资源；
- 初始化 PCB，如进程标识符、CPU 初始状态等；
- 把新进程的状态设置为就绪态，并将其移入就绪队列，等待被调度运行。

**「什么事件会触发进程的创建呢」**？有如下四种情况：

- 用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程
- 作业调度：多道批处理系统中，有新的作业放入内存中，会为其建立一个新的进程
- 提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求
- 应用请求：由用户进程主动请求创建一个子进程

#### 进程的终止

进程的终止也称为撤销，进程完成特定工作或出现严重错误后必须被终止。引起进程终止的事件有三种：

- 正常结束：进程自己请求终止（exit 系统调用）
- 异常结束：比如整数除 0，非法使用特权指令，然后被操作系统强行终止
- 外界干预：Ctrl + Alt + delete 打开进程管理器，用户手动杀死进程

终止（撤销）进程的过程，也就是**「撤销原语」**包含的内容如下：

- 从 PCB 集合中找到终止进程的 PCB；
- 若进程处于运行态，则立即剥夺其 CPU，终止该进程的执行，然后将 CPU 资源分配给其他进程；
- 如果其还有子进程，则应将其所有子进程终止；
- 将该进程所拥有的全部资源都归还给父进程或操作系统；
- 回收 PCB 并将其归还至 PCB 池。

#### 进程的阻塞和唤醒

进程阻塞是指进程让出 CPU 资源转而等待一个事件，如等待资源、等待 I/O 操作完成等。进程通常使用阻塞原语来阻塞自己，所以阻塞是进程的自主行为，是一个同步事件。当等待事件完成时会产生一个中断，激活操作系统，在系统的控制下将被阻塞的进程唤醒，也就是唤醒原语。

进程的阻塞和唤醒显然是由进程切换来完成的。

进程的阻塞步骤，也就是**「阻塞原语」**的内容为：

- 找到将要被阻塞的进程对应的 PCB；
- 保护进程运行现场，将 PCB 状态信息设置为阻塞态，暂时停止进程运行；
- 将该 PCB 插入相应事件的阻塞队列（等待队列）。

进程的唤醒步骤，也就是**「唤醒原语」**的内容为：

- 在该事件的阻塞队列中找到相应进程的 PCB；
- 将该 PCB 从阻塞队列中移出，并将进程的状态设置为就绪态；
- 把该 PCB 插入到就绪队列中，等待被调度程序调度。

阻塞原语和唤醒原语的作用正好相反，**「阻塞原语使得进程从运行态转为阻塞态，而唤醒原语使得进程从阻塞态转为就绪态」**。如果某个进程使用阻塞原语来阻塞自己，那么他就必须使用唤醒原语来唤醒自己，因何事阻塞，就由何事唤醒，否则被阻塞的进程将永远处于阻塞态。因此，**「阻塞原语和唤醒原语是成对出现的」**。

###   进程上下文切换

所谓进程的上下文切换，就是说各个进程之间是共享 CPU 资源的，不可能一个进程永远占用着 CPU 资源，不同的时候进程之间需要切换，使得不同的进程被分配 CPU 资源，这个过程就是进程的上下文切换，**「一个进程切换到另一个进程运行」**。

因为进程是由内核进行管理和调度的，所以**「进程的上下文切换一定发生在内核态」**。

进程上下文的切换也是一个原语操作，称为**「切换原语」**，其内容如下：

- 首先，将进程 A 的运行环境信息存入 PCB，这个运行环境信息就是进程的上下文（Context）
- 然后，将 PCB 移入相应的进程队列；
- 选择另一个进程 B 进行执行，并更新其 PCB 中的状态为运行态
- 当进程 A 被恢复运行的时候，根据它的 PCB 恢复进程 A 所需的运行环境

引起进程上下文切换的事件，也就是某个占用 CPU 资源运行的当前进程被赶出 CPU 的原因有如下：

- 当前进程的时间片到
- 有更高优先级的进程到达
- 当前进程主动阻塞
- 当前进程终止





###  [Linux 中进程管理系统调用](https://mp.weixin.qq.com/s/Yb2AhzXVt-waLtQL9hVXEg)

现在关注一下 Linux 系统中与进程管理相关的系统调用。在了解之前你需要先知道一下什么是系统调用。

操作系统为我们屏蔽了硬件和软件的差异，它的最主要功能就是为用户提供一种抽象，隐藏内部实现，让用户只关心在 GUI 图形界面下如何使用即可。操作系统可以分为两种模式

- 内核态：操作系统内核使用的模式
- 用户态：用户应用程序所使用的模式

我们常说的`上下文切换` 指的就是内核态模式和用户态模式的频繁切换。而`系统调用`指的就是引起内核态和用户态切换的一种方式，系统调用通常在后台静默运行，表示计算机程序向其操作系统内核请求服务。

系统调用指令有很多，下面是一些与进程管理相关的最主要的系统调用。

> fork

fork 调用用于创建一个与父进程相同的子进程，创建完进程后的子进程拥有和父进程一样的程序计数器、相同的 CPU 寄存器、相同的打开文件。



> exec

exec 系统调用用于执行驻留在活动进程中的文件，调用 exec 后，新的可执行文件会替换先前的可执行文件并获得执行。也就是说，调用 exec 后，会将旧文件或程序替换为新文件或执行，然后执行文件或程序。新的执行程序被加载到相同的执行空间中，因此进程的 `PID`不会修改，因为我们**没有创建新进程，只是替换旧进程**。但是进程的数据、代码、堆栈都已经被修改。如果当前要被替换的进程包含多个线程，那么所有的线程将被终止，新的进程映像被加载执行。

这里需要解释一下`进程映像(Process image)` 的概念

**什么是进程映像呢**？进程映像是执行程序时所需要的可执行文件，通常会包括下面这些东西

- **代码段（codesegment/textsegment）**

又称文本段，用来存放指令，运行代码的一块内存空间

此空间大小在代码运行前就已经确定

内存空间一般属于只读，某些架构的代码也允许可写

在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。

- **数据段（datasegment）**

可读可写

存储初始化的全局变量和初始化的 static 变量

数据段中数据的生存期是随程序持续性（随进程持续性） 随进程持续性：进程创建就存在，进程死亡就消失

- **bss 段（bsssegment）：**

可读可写

存储未初始化的全局变量和未初始化的 static 变量

bss 段中的数据一般默认为 0

- **Data 段**

是可读写的，因为变量的值可以在运行时更改。此段的大小也固定。

- **栈（stack）：**

可读可写

存储的是函数或代码中的局部变量(非 static 变量)

栈的生存期随代码块持续性，代码块运行就给你分配空间，代码块结束，就自动回收空间

- **堆（heap）：**

可读可写

存储的是程序运行期间动态分配的 malloc/realloc 的空间

堆的生存期随进程持续性，从 malloc/realloc 到 free 一直存在

下面是这些区域的构成图

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaRQzFQFGQcETRPzYXnxtWOtSDG2dd5po5BOWDpFCIL9qSsvY2P7ZjBppD97UWKy6ic1eFzjKBcfwZw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

exec 系统调用是一些函数的集合，这些函数是

- execl
- execle
- execlp
- execv
- execve
- execvp

下面来看一下 exec 的工作原理

1. 当前进程映像被替换为新的进程映像
2. 新的进程映像是你做为 exec 传递的参数
3. 结束当前正在运行的进程
4. 新的进程映像有 PID，相同的环境和一些文件描述符(因为未替换进程，只是替换了进程映像)
5. CPU 状态和虚拟内存受到影响，当前进程映像的虚拟内存映射被新进程映像的虚拟内存代替。

> waitpid

等待子进程结束或终止

> exit

在许多计算机操作系统上，计算机进程的终止是通过执行 `exit` 系统调用命令执行的。0 表示进程能够正常结束，其他值表示进程以非正常的行为结束。

其他一些常见的系统调用如下

| 系统调用指令 | 描述                             |
| :----------- | :------------------------------- |
| pause        | 挂起信号                         |
| nice         | 改变分时进程的优先级             |
| ptrace       | 进程跟踪                         |
| kill         | 向进程发送信号                   |
| pipe         | 创建管道                         |
| mkfifo       | 创建 fifo 的特殊文件（命名管道） |
| sigaction    | 设置对指定信号的处理方法         |
| msgctl       | 消息控制操作                     |
| semctl       | 信号量控制                       |



## Linux 进程间通信

Linux 进程间的通信机制通常被称为 `Internel-Process communication,IPC`下面我们来说一说 Linux 进程间通信的机制，大致来说，Linux 进程间的通信机制可以分为 6 种

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaRQzFQFGQcETRPzYXnxtWOtP5IhMLrNop6iaPNJrKWw6zF8Cia97FdkkpXicVibwVWQYGkNXN6ibwnAPgA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

下面我们分别对其进行概述

### <span id="信号2">信号 signal</span>

信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送`异步事件信号`来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。

你可以在 Linux 系统上输入 `kill -l` 来列出系统使用的信号，下面是我提供的一些信号

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaRQzFQFGQcETRPzYXnxtWOt3hAicRftdqkewydkbQhb4ZA8xZTTUZVS3dHp4EpYsg3Pia2gSvkvzWSQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：`SIGSTOP` 和 `SIGKILL` 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。

操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。

例如：当进程收到 `SIGFPE` 浮点异常的信号后，默认操作是对其进行 `dump(转储)`和退出。信号没有优先级的说法。如果同时为某个进程产生了两个信号，则可以将它们呈现给进程或者以任意的顺序进行处理。

下面我们就来看一下这些信号是干什么用的

- SIGABRT 和 SIGIOT

SIGABRT 和 SIGIOT 信号发送给进程，告诉其进行终止，这个 信号通常在调用 C标准库的`abort()`函数时由进程本身启动

- SIGALRM 、 SIGVTALRM、SIGPROF

当设置的时钟功能超时时会将 SIGALRM 、 SIGVTALRM、SIGPROF 发送给进程。当实际时间或时钟时间超时时，发送 SIGALRM。当进程使用的 CPU 时间超时时，将发送 SIGVTALRM。当进程和系统代表进程使用的CPU 时间超时时，将发送 SIGPROF。

- SIGBUS

SIGBUS 将造成`总线中断`错误时发送给进程

- SIGCHLD

当子进程终止、被中断或者被中断恢复，将 SIGCHLD 发送给进程。此信号的一种常见用法是指示操作系统在子进程终止后清除其使用的资源。

- SIGCONT

SIGCONT 信号指示操作系统继续执行先前由 SIGSTOP 或 SIGTSTP 信号暂停的进程。该信号的一个重要用途是在 Unix shell 中的作业控制中。

- SIGFPE

SIGFPE 信号在执行错误的算术运算（例如除以零）时将被发送到进程。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaRQzFQFGQcETRPzYXnxtWOtrvAYhGPeUVoHxmrxKAIhhcfc3uXX3hfXqRLBozEjyh01qdkkOqjySw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- SIGUP

当 SIGUP 信号控制的终端关闭时，会发送给进程。许多守护程序将重新加载其配置文件并重新打开其日志文件，而不是在收到此信号时退出。

- SIGILL

SIGILL 信号在尝试执行非法、格式错误、未知或者特权指令时发出

- SIGINT

当用户希望中断进程时，操作系统会向进程发送 SIGINT 信号。用户输入 ctrl - c 就是希望中断进程。

- SIGKILL

SIGKILL 信号发送到进程以使其马上进行终止。与 SIGTERM 和 SIGINT 相比，这个信号无法捕获和忽略执行，并且进程在接收到此信号后无法执行任何清理操作，下面是一些例外情况

僵尸进程无法杀死，因为僵尸进程已经死了，它在等待父进程对其进行捕获

处于阻塞状态的进程只有再次唤醒后才会被 kill 掉

`init` 进程是 Linux 的初始化进程，这个进程会忽略任何信号。

SIGKILL 通常是作为最后杀死进程的信号、它通常作用于 SIGTERM 没有响应时发送给进程。

- SIGPIPE

SIGPIPE 尝试写入进程管道时发现管道未连接无法写入时发送到进程

- SIGPOLL

当在明确监视的文件描述符上发生事件时，将发送 SIGPOLL 信号。

- SIGRTMIN 至 SIGRTMAX

SIGRTMIN 至 SIGRTMAX 是`实时信号`

- SIGQUIT

当用户请求退出进程并执行核心转储时，SIGQUIT 信号将由其控制终端发送给进程。

- SIGSEGV

当 SIGSEGV 信号做出无效的虚拟内存引用或分段错误时，即在执行分段违规时，将其发送到进程。

- SIGSTOP

SIGSTOP 指示操作系统终止以便以后进行恢复时

- SIGSYS

当 SIGSYS 信号将错误参数传递给系统调用时，该信号将发送到进程。

- SIGTERM

我们上面简单提到过了 SIGTERM 这个名词，这个信号发送给进程以请求终止。与 SIGKILL 信号不同，该信号可以被过程捕获或忽略。这允许进程执行良好的终止，从而释放资源并在适当时保存状态。SIGINT 与SIGTERM 几乎相同。

- SIGTSIP

SIGTSTP 信号由其控制终端发送到进程，以请求终端停止。

- SIGTTIN 和 SIGTTOU

当 SIGTTIN 和SIGTTOU 信号分别在后台尝试从 tty 读取或写入时，信号将发送到该进程。

- SIGTRAP

在发生异常或者 trap 时，将 SIGTRAP 信号发送到进程

- SIGURG

当套接字具有可读取的紧急或带外数据时，将 SIGURG 信号发送到进程。

- SIGUSR1 和 SIGUSR2

SIGUSR1 和 SIGUSR2 信号被发送到进程以指示用户定义的条件。

- SIGXCPU

当 SIGXCPU 信号耗尽 CPU 的时间超过某个用户可设置的预定值时，将其发送到进程

- SIGXFSZ

当 SIGXFSZ 信号增长超过最大允许大小的文件时，该信号将发送到该进程。

- SIGWINCH

SIGWINCH 信号在其控制终端更改其大小（窗口更改）时发送给进程。

### 管道 pipe

Linux 系统中的进程可以通过建立管道 pipe 进行通信

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaRQzFQFGQcETRPzYXnxtWOtrHFf4S6ibmfyq2N85zFxdW8IgnkMxyF2cvblHC3Kbbe3a8BMpH7pyqQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的`管线 pipelines` 就是用管道实现的，当 shell 发现输出

```
sort <f | head
```

它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaRQzFQFGQcETRPzYXnxtWOtaXHx7mIsrAmdKzIBwv3vUHbiaXDwoo0L0yuGwehiaficonL2aWTDz3nibQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

管道实际上就是 `|`，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。

### 共享内存 shared memory

两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaRQzFQFGQcETRPzYXnxtWOtzOrlYsXSJnzIld0U6fYckSY3YJXF3OY5LFdwx6S81iaficb7WfFcxN4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

在使用共享内存前，需要经过一系列的调用流程，流程如下

- 创建共享内存段或者使用已创建的共享内存段`(shmget())`
- 将进程附加到已经创建的内存段中`(shmat())`
- 从已连接的共享内存段分离进程`(shmdt())`
- 对共享内存段执行控制操作`(shmctl())`

### 先入先出队列 FIFO

先入先出队列 FIFO 通常被称为 `命名管道(Named Pipes)`，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为

![图片](https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaRQzFQFGQcETRPzYXnxtWOtqgBofiaKl3ic9yxKX5EQOZibbqpIiaddu5sicGCShAxRJ9xJLyR6CGHbrQQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。

### 消息队列 Message Queue

一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是`严格模式`， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 `非严格模式`，消息的顺序性不是非常重要。

### 套接字 Socket

还有一种管理两个进程间通信的是使用 `socket`，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如`TCP（传输控制协议）`或较低级别`UDP（用户数据报协议）`等基础协议的支持。

套接字有以下几种分类

- `顺序包套接字(Sequential Packet Socket)`：此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。
- `数据报套接字(Datagram Socket)`：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。
- `流式套接字(Stream Socket)`：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。
- `原始套接字(Raw Socket)`：可以使用原始套接字访问基础通信协议。





#  匿名管道 （PIPE）

[图解 | Linux进程通信 - 管道实现](https://mp.weixin.qq.com/s?__biz=MzUxMjEyNDgyNw==&mid=2247499691&idx=1&sn=75c07479ba7cc715a5eda2f3fb24f171&chksm=f96b8d5fce1c044907d4504a7d2320f7c4937b2b93fab6476b24c04cc6c65cdedb0b51381898&mpshare=1&scene=24&srcid=1116UMh6raq0Ugo1G9duNms1&sharer_sharetime=1637036128748&sharer_shareid=0d5c82ce3c8b7c8f30cc9a686416d4a8#rd)



处于安全的考虑，不同进程之间的内存空间是相互隔离的，也就是说 `进程A` 是不能访问 `进程B` 的内存空间，反之亦然。如果不同进程间能够相互访问和修改对方的内存，那么当前进程的内存就有可能被其他进程非法修改，从而导致安全隐患。

不同的进程就像是大海上孤立的岛屿，它们之间不能直接相互通信，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J6BZXhG7ibPdIvLnOZzmSHUIBNWiaLL6oksId5ic1EFd6wZluLnjwuibl9YciaX90KNKenaSZ7YibD9iaibGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



但某些场景下，不同进程间需要相互通信，比如：`进程A` 负责处理用户的请求，而 `进程B` 负责保存处理后的数据。那么当 `进程A` 处理完请求后，就需要把处理后的数据提交给 `进程B` 进行存储。此时，`进程A` 就需要与 `进程B` 进行通信。如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J6BZXhG7ibPdIvLnOZzmSHUIVnoLfEFNX6DY6vdOP6uUB5YegiaRtFsu3ZSZHYZxJsIKrnokExvlxgg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

由于不同进程间是相互隔离的，所以必须借助内核来作为桥梁来进行相互通信，内核相当于岛屿之间的轮船，如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J6BZXhG7ibPdIvLnOZzmSHUIyONWtPtgyTQ4ZamOKkoQaGHf8XTxxtB7KFDr54dJYnX6HgZqKQibbIg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



内核提供多种进程间通信的方式，如：`共享内存`，`信号`，`消息队列` 和 `管道（pipe）` 等。本文主要介绍 `管道` 的原理与实现。



## 一、管道的使用

`管道` 一般用于父子进程之间相互通信，一般的用法如下：

- 父进程使用 `pipe` 系统调用创建一个管道。
- 然后父进程使用 `fork` 系统调用创建一个子进程。
- 由于子进程会继承父进程打开的文件句柄，所以父子进程可以通过新创建的管道进行通信。

其原理如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J6BZXhG7ibPdIvLnOZzmSHUINC0dmrvoTLyZfxjrialsDM0lLKtYGZzHFzBCxiajo531Q5KIcIhfwiawQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

由于管道分为读端和写端，所以需要两个文件描述符来管理管道：`fd[0]` 为读端，`fd[1]` 为写端。

下面代码介绍了怎么使用 `pipe` 系统调用来创建一个管道：


```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>
#include <string.h>

int main()
{
    int ret = -1;
    int fd[2];  // 用于管理管道的文件描述符
    pid_t pid;
    char buf[512] = {0};
    char *msg = "hello world";

    // 创建一个管理
    ret = pipe(fd);
    if (-1 == ret) {
        printf("failed to create pipe\n");
        return -1;
    }
  
    pid = fork();     // 创建子进程

    if (0 == pid) {   // 子进程
        close(fd[0]); // 关闭管道的读端
        ret = write(fd[1], msg, strlen(msg)); // 向管道写端写入数据
        exit(0);
    } else {          // 父进程
        close(fd[1]); // 关闭管道的写端
        ret = read(fd[0], buf, sizeof(buf)); // 从管道的读端读取数据
        printf("parent read %d bytes data: %s\n", ret, buf);
    }

    return 0;
}
```



编译代码：

```c
[root@localhost pipe]# gcc -g pipe.c -o pipe
```

运行代码，输出结果如下：

```c
[root@localhost pipe]# ./pipe
parent read 11 bytes data: hello world
```










## 二、管道的实现

每个进程的用户空间都是独立的，但内核空间却是共用的。所以，进程间通信必须由内核提供服务。前面介绍了 `管道(pipe)` 的使用，接下来将会介绍管道在内核中的实现方式。

> 本文使用 Linux-2.6.23 内核作为分析对象。

### 1. 环形缓冲区（Ring Buffer）

在内核中，`管道` 使用了环形缓冲区来存储数据。环形缓冲区的原理是：把一个缓冲区当成是首尾相连的环，其中通过读指针和写指针来记录读操作和写操作位置。如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J6BZXhG7ibPdIvLnOZzmSHUIzZNsOSQDhmdLmDTJkJ6rkSkzicfNxYoRECaapW2yYJpFT56aicQoktFg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



在 Linux 内核中，使用了 16 个内存页作为环形缓冲区，所以这个环形缓冲区的大小为 64KB（16 * 4KB）。

当向管道写数据时，从写指针指向的位置开始写入，并且将写指针向前移动。而从管道读取数据时，从读指针开始读入，并且将读指针向前移动。当对没有数据可读的管道进行读操作，将会阻塞当前进程。而对没有空闲空间的管道进行写操作，也会阻塞当前进程。

> 注意：可以将管道文件描述符设置为非阻塞，这样对管道进行读写操作时，就不会阻塞当前进程。

### 2. 管道对象

在 Linux 内核中，管道使用 `pipe_inode_info` 对象来进行管理。我们先来看看 `pipe_inode_info` 对象的定义，如下所示：

```
struct pipe_inode_info {
    wait_queue_head_t wait;
    unsigned int nrbufs,
    unsigned int curbuf;
    ...
    unsigned int readers;
    unsigned int writers;
    unsigned int waiting_writers;
    ...
    struct inode *inode;
    struct pipe_buffer bufs[16];
};
```

下面介绍一下 `pipe_inode_info` 对象各个字段的作用：

- `wait`：等待队列，用于存储正在等待管道可读或者可写的进程。
- `bufs`：环形缓冲区，由 16 个 `pipe_buffer` 对象组成，每个 `pipe_buffer` 对象拥有一个内存页 ，后面会介绍。
- `nrbufs`：表示未读数据已经占用了环形缓冲区的多少个内存页。
- `curbuf`：表示当前正在读取环形缓冲区的哪个内存页中的数据。
- `readers`：表示正在读取管道的进程数。
- `writers`：表示正在写入管道的进程数。
- `waiting_writers`：表示等待管道可写的进程数。
- `inode`：与管道关联的 `inode` 对象。

由于环形缓冲区是由 16 个 `pipe_buffer` 对象组成，所以下面我们来看看 `pipe_buffer` 对象的定义：

```
struct pipe_buffer {
    struct page *page;
    unsigned int offset;
    unsigned int len;
    ...
};
```

下面介绍一下 `pipe_buffer` 对象各个字段的作用：

- `page`：指向 `pipe_buffer` 对象占用的内存页。
- `offset`：如果进程正在读取当前内存页的数据，那么 `offset` 指向正在读取当前内存页的偏移量。
- `len`：表示当前内存页拥有未读数据的长度。

下图展示了 `pipe_inode_info` 对象与 `pipe_buffer` 对象的关系：

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/ciab8jTiab9J6BZXhG7ibPdIvLnOZzmSHUIAK4JQUrI4AykUlx1RyPLbr6QYmFQicezZuibGx1EWY6fmY6Zib9ZrNdIQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



管道的环形缓冲区实现方式与经典的环形缓冲区实现方式有点区别，经典的环形缓冲区一般先申请一块地址连续的内存块，然后通过读指针与写指针来对读操作与写操作进行定位。

但为了减少对内存的使用，内核不会在创建管道时就申请 64K 的内存块，而是在进程向管道写入数据时，按需来申请内存。

那么当进程从管道读取数据时，内核怎么处理呢？下面我们来看看管道读操作的实现方式。

### 3. 读操作

从 `经典的环形缓冲区` 中读取数据时，首先通过读指针来定位到读取数据的起始地址，然后判断环形缓冲区中是否有数据可读，如果有就从环形缓冲区中读取数据到用户空间的缓冲区中。如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J6BZXhG7ibPdIvLnOZzmSHUI7mqD5xiajPpVjSVfJ3POib41icdZOlJJyC1xb71yCPnWS9sKTAQguRTRA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



而 `管道的环形缓冲区` 与 `经典的环形缓冲区` 实现稍有不同，`管道的环形缓冲区` 其读指针是由 `pipe_inode_info` 对象的 `curbuf` 字段与 `pipe_buffer` 对象的 `offset` 字段组合而成：

- `pipe_inode_info` 对象的 `curbuf` 字段表示读操作要从 `bufs` 数组的哪个 `pipe_buffer` 中读取数据。
- `pipe_buffer` 对象的 `offset` 字段表示读操作要从内存页的哪个位置开始读取数据。

读取数据的过程如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J6BZXhG7ibPdIvLnOZzmSHUIPAF9uEckg31emRT34t7QfZgRL7Q9vRkpo3XlqKEXCw3kSgN5ib2GPAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



从缓冲区中读取到 n 个字节的数据后，会相应移动读指针 n 个字节的位置（也就是增加 `pipe_buffer` 对象的 `offset` 字段），并且减少 n 个字节的可读数据长度（也就是减少 `pipe_buffer` 对象的 `len` 字段）。

当 `pipe_buffer` 对象的 `len` 字段变为 0 时，表示当前 `pipe_buffer` 没有可读数据，那么将会对 `pipe_inode_info` 对象的 `curbuf` 字段移动一个位置，并且其 `nrbufs` 字段进行减一操作。

我们来看看管道读操作的代码实现，读操作由 `pipe_read` 函数完成。为了突出重点，我们只列出关键代码，如下所示：

```
static ssize_t
pipe_read(struct kiocb *iocb, const struct iovec *_iov, unsigned long nr_segs,
          loff_t pos)
{
    ...
    struct pipe_inode_info *pipe;

    // 1. 获取管道对象
    pipe = inode->i_pipe;

    for (;;) {
        // 2. 获取管道未读数据占有多少个内存页
        int bufs = pipe->nrbufs;

        if (bufs) {
            // 3. 获取读操作应该从环形缓冲区的哪个内存页处读取数据
            int curbuf = pipe->curbuf;  
            struct pipe_buffer *buf = pipe->bufs + curbuf;
            ...

            /* 4. 通过 pipe_buffer 的 offset 字段获取真正的读指针,
             *    并且从管道中读取数据到用户缓冲区.
             */
            error = pipe_iov_copy_to_user(iov, addr + buf->offset, chars, atomic);
            ...

            ret += chars;
            buf->offset += chars; // 增加 pipe_buffer 对象的 offset 字段的值
            buf->len -= chars;    // 减少 pipe_buffer 对象的 len 字段的值

            /* 5. 如果当前内存页的数据已经被读取完毕 */
            if (!buf->len) {
                ...
                curbuf = (curbuf + 1) & (PIPE_BUFFERS - 1);
                pipe->curbuf = curbuf; // 移动 pipe_inode_info 对象的 curbuf 指针
                pipe->nrbufs = --bufs; // 减少 pipe_inode_info 对象的 nrbufs 字段
                do_wakeup = 1;
            }

            total_len -= chars;

            // 6. 如果读取到用户期望的数据长度, 退出循环
            if (!total_len)
                break;
        }
        ...
    }

    ...
    return ret;
}
```

上面代码总结来说分为以下步骤：

- 通过文件 `inode` 对象来获取到管道的 `pipe_inode_info` 对象。
- 通过 `pipe_inode_info` 对象的 `nrbufs` 字段获取管道未读数据占有多少个内存页。
- 通过 `pipe_inode_info` 对象的 `curbuf` 字段获取读操作应该从环形缓冲区的哪个内存页处读取数据。
- 通过 `pipe_buffer` 对象的 `offset` 字段获取真正的读指针， 并且从管道中读取数据到用户缓冲区。
- 如果当前内存页的数据已经被读取完毕，那么移动 `pipe_inode_info` 对象的 `curbuf` 指针，并且减少其 `nrbufs` 字段的值。
- 如果读取到用户期望的数据长度，退出循环。

### 4. 写操作

分析完管道读操作的实现后，接下来，我们分析一下管道写操作的实现。

`经典的环形缓冲区` 写入数据时，首先通过写指针进行定位要写入的内存地址，然后判断环形缓冲区的空间是否足够，足够就把数据写入到环形缓冲区中。如下图所示：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J6BZXhG7ibPdIvLnOZzmSHUIj6TvOv15xU8VRxkNCJN0T7M0YBGKCkgW0hmDK8dpecmbEp78RIoJXg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



但 `管道的环形缓冲区` 并没有保存 `写指针`，而是通过 `读指针` 计算出来。那么怎么通过读指针计算出写指针呢？

其实很简单，就是：

> 写指针 = 读指针 + 未读数据长度

下面我们来看看，向管道写入 200 字节数据的过程示意图，如下所示：



如上图所示，向管道写入数据时：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J6BZXhG7ibPdIvLnOZzmSHUIHJ57Ygt5R9tgWVlhccnl6suYCWxSMJP3gSUq6aHMicJOF87ysGrjnVw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

- 首先通过 `pipe_inode_info` 的 `curbuf` 字段和 `nrbufs` 字段来定位到，应该向哪个 `pipe_buffer` 写入数据。
- 然后再通过 `pipe_buffer` 对象的 `offset` 字段和 `len` 字段来定位到，应该写入到内存页的哪个位置。

下面我们通过源码来分析，写操作是怎么实现的，代码如下（为了特出重点，代码有所删减）：

```
static ssize_t
pipe_write(struct kiocb *iocb, const struct iovec *_iov, unsigned long nr_segs,
           loff_t ppos)
{
    ...
    struct pipe_inode_info *pipe;
    ...
    pipe = inode->i_pipe;
    ...
    chars = total_len & (PAGE_SIZE - 1); /* size of the last buffer */

    // 1. 如果最后写入的 pipe_buffer 还有空闲的空间
    if (pipe->nrbufs && chars != 0) {
        // 获取写入数据的位置
        int lastbuf = (pipe->curbuf + pipe->nrbufs - 1) & (PIPE_BUFFERS-1);
        struct pipe_buffer *buf = pipe->bufs + lastbuf;
        const struct pipe_buf_operations *ops = buf->ops;
        int offset = buf->offset + buf->len;

        if (ops->can_merge && offset + chars <= PAGE_SIZE) {
            ...
            error = pipe_iov_copy_from_user(offset + addr, iov, chars, atomic);
            ...
            buf->len += chars;
            total_len -= chars;
            ret = chars;

            // 如果要写入的数据已经全部写入成功, 退出循环
            if (!total_len)
                goto out;
        }
    }

    // 2. 如果最后写入的 pipe_buffer 空闲空间不足, 那么申请一个新的内存页来存储数据
    for (;;) {
        int bufs;
        ...
        bufs = pipe->nrbufs;

        if (bufs < PIPE_BUFFERS) {
            int newbuf = (pipe->curbuf + bufs) & (PIPE_BUFFERS-1);
            struct pipe_buffer *buf = pipe->bufs + newbuf;
            ...

            // 申请一个新的内存页
            if (!page) {
                page = alloc_page(GFP_HIGHUSER);
                ...
            }
            ...
            error = pipe_iov_copy_from_user(src, iov, chars, atomic);
            ...
            ret += chars;

            buf->page = page;
            buf->ops = &anon_pipe_buf_ops;
            buf->offset = 0;
            buf->len = chars;

            pipe->nrbufs = ++bufs;
            pipe->tmp_page = NULL;

            // 如果要写入的数据已经全部写入成功, 退出循环
            total_len -= chars;
            if (!total_len)
                break;
        }
        ...
    }

out:
    ...
    return ret;
}
```

上面代码有点长，但是逻辑却很简单，主要进行如下操作：

- 如果上次写操作写入的 `pipe_buffer` 还有空闲的空间，那么就将数据写入到此 `pipe_buffer` 中，并且增加其 `len` 字段的值。
- 如果上次写操作写入的 `pipe_buffer` 没有足够的空闲空间，那么就新申请一个内存页，并且把数据保存到新的内存页中，并且增加 `pipe_inode_info` 的 `nrbufs` 字段的值。
- 如果写入的数据已经全部写入成功，那么就退出写操作。

## 三、思考一下

管道读写操作的实现已经分析完毕，现在我们来思考一下以下问题。

### 1. 为什么父子进程可以通过管道来通信？

这是因为父子进程通过 `pipe` 系统调用打开的管道，在内核空间中指向同一个管道对象（`pipe_inode_info`）。所以父子进程共享着同一个管道对象，那么就可以通过这个共享的管道对象进行通信。

### 2. 为什么内核要使用 16 个内存页进行数据存储？

这是为了减少内存使用。

因为使用 `pipe` 系统调用打开管道时，并没有立刻申请内存页，而是当有进程向管道写入数据时，才会按需申请内存页。当内存页的数据被读取完后，内核会将此内存页回收，来减少管道对内存的使用。



## 匿名管道pipe

[c语言 - 进程间通信 管道](https://zfl9.github.io/c-ipc-pipe.html)



如果你使用过Linux的命令，那么对于管道这个名词你一定不会感觉到陌生，因为我们通常通过符号”|”来使用管道；

但是管道的真正定义是什么呢？
管道是一个进程连接数据流到另一个进程的通道，它通常是用作把一个进程的输出通过管道连接到另一个进程的输入；

举个例子，在shell中输入命令：`ls -l | grep string`
我们知道ls命令（其实也是一个进程）会把当前目录中的文件都列出来，但是它不会直接输出，而是把本来要输出到屏幕上的数据通过管道输出到grep这个进程中，作为grep这个进程的输入，然后这个进程对输入的信息进行筛选，把存在string的信息的字符串（以行为单位）打印在屏幕上；

**匿名管道pipe**
`int pipe(filedes[2]);`：创建一个匿名管道

- 头文件：`unistd.h`
- `filedes[2]`：输出参数，用于接收pipe返回的两个文件描述符；`filedes[0]`读管道、`filedes[1]`写管道.
- 返回值：成功返回0，失败返回-1，并设置errno.

匿名管道实质上是一个`先进先出（FIFO）的队列`：
`filedes[0]`是队头（front），`filedes[1]`是队尾（rear）；

数据从队尾进，从队头出，遵循先进先出的原则；

pipe()创建的管道，其实是一个在内核中的缓冲区，该缓冲区的大小一般为一页，即4K字节；

先来看一个简单的例子：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>

int main(int argc, char *argv[]){
    if(argc < 3){
        fprintf(stderr, "usage: %s parent_sendmsg child_sendmsg\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int pipes[2];
    if(pipe(pipes) < 0){
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    pid_t pid = fork();
    if(pid < 0){
        perror("fork");
        exit(EXIT_FAILURE);
    }else if(pid > 0){
        char buf[BUFSIZ + 1];
        int nbuf;
        strcpy(buf, argv[1]);
        write(pipes[1], buf, strlen(buf));

        sleep(1);

        nbuf = read(pipes[0], buf, BUFSIZ);
        buf[nbuf] = 0;
        printf("parent_proc(%d) recv_from_child: %s\n", getpid(), buf);

        close(pipes[0]);
        close(pipes[1]);
    }else if(pid == 0){
        char buf[BUFSIZ + 1];
        int nbuf = read(pipes[0], buf, BUFSIZ);
        buf[nbuf] = 0;
        printf("child_proc(%d) recv_from_parent: %s\n", getpid(), buf);

        strcpy(buf, argv[2]);
        write(pipes[1], buf, strlen(buf));

        close(pipes[0]);
        close(pipes[1]);
    }

    return 0;
}
```



```c
# root @ arch in ~/work on git:master x [14:44:49]
$ gcc a.c

# root @ arch in ~/work on git:master x [14:44:52]
$ ./a.out from_parent from_child
child_proc(4335) recv_from_parent: from_parent
parent_proc(4334) recv_from_child: from_child
```



注意到父进程的`sleep(1);`语句：

fork调用之前，父进程创建了一个匿名管道，假设文件描述符为`filedes[] = {3, 4}`，即3为队头，4为队尾；

fork调用之后，创建了一个子进程，子进程也拥有了这两个文件描述符，引用计数都分别加1；

因为实质上在内核中只存在一个管道缓冲区，是父进程创建的，只不过子进程通过fork也拥有了它的引用；所以，如果父进程发送msg之后，子进程没有及时的读取走数据，那么会被父进程后面的read读取，违背了我们的目的；

所以，一般是不建议上面这种做法的，通常做法是：一个进程要么往管道里写数据，要么从管道里读数据；如果既需要读又需要写，那么需要创建两个匿名管道，一个专门读取数据，一个专门写入数据；

比如这样：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>

int main(int argc, char *argv[]){
    if(argc < 3){
        fprintf(stderr, "usage: %s parent_sendmsg child_sendmsg\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int pipes1[2], pipes2[2];
    if(pipe(pipes1) < 0 || pipe(pipes2) < 0){
        perror("pipe");
        exit(EXIT_FAILURE);
    }

    pid_t pid = fork();
    if(pid < 0){
        perror("fork");
        exit(EXIT_FAILURE);
    }else if(pid > 0){
        close(pipes1[0]);
        close(pipes2[1]);

        char buf[BUFSIZ + 1];
        strcpy(buf, argv[1]);
        write(pipes1[1], buf, strlen(buf));

        int nbuf = read(pipes2[0], buf, BUFSIZ);
        buf[nbuf] = 0;
        printf("parent_proc(%d) recv_msg: %s\n", getpid(), buf);

        close(pipes1[1]);
        close(pipes2[0]);
    }else if(pid == 0){
        close(pipes1[1]);
        close(pipes2[0]);

        char buf[BUFSIZ + 1];
        int nbuf = read(pipes1[0], buf, BUFSIZ);
        buf[nbuf] = 0;
        printf("child_proc(%d) recv_msg: %s\n", getpid(), buf);

        strcpy(buf, argv[2]);
        write(pipes2[1], buf, strlen(buf));

        close(pipes1[0]);
        close(pipes2[1]);
    }

    return 0;
}
```



```c
# root @ arch in ~/work on git:master x [15:17:04] C:130
$ gcc a.c

# root @ arch in ~/work on git:master x [15:17:07]
$ ./a.out parent child
child_proc(4622) recv_msg: parent
parent_proc(4621) recv_msg: child
```



**默认的阻塞模式**
pipe()创建的管道默认是阻塞模式的，阻塞和非阻塞的区别与socket的阻塞、非阻塞很相似：

**管道读写规则**
当没有数据可读时

- `O_NONBLOCK`关闭：read调用阻塞，即进程暂停执行，一直等到有数据来到为止；
- `O_NONBLOCK`打开：read调用返回-1，errno值为EAGAIN；

当管道满的时候

- `O_NONBLOCK`关闭：write调用阻塞，直到有进程读走数据；
- `O_NONBLOCK`打开：调用返回-1，errno值为EAGAIN；

如果所有管道写端对应的文件描述符被关闭，则read返回0；
如果所有管道读端对应的文件描述符被关闭，则write操作会产生信号SIGPIPE；

当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性；
当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性；

PIPE_BUF的大小为4096字节，注意，这不是管道的缓冲区大小，这个大小和写入的原子性有关；
所谓原子性：

- 阻塞模式时且`n<PIPE_BUF`：写入具有原子性，如果没有足够的空间供n个字节全部写入，则阻塞直到有足够空间将n个字节全部写入管道；
- 非阻塞模式时且`n<PIPE_BUF`：写入具有原子性，立即全部成功写入，否则一个都不写入，返回错误；
- 阻塞模式时且`n>PIPE_BUF`：不具有原子性，可能中间有其他进程穿插写入，直到将n字节全部写入才返回，否则阻塞等待写入；
- 非阻塞模式时且`n>PIPE_BUF`：不具有原子性，如果管道满的，则立即失败，一个都不写入，返回错误，如果不满，则返回写入的字节数，即部分写入，写入时可能有其他进程穿插写入；

**设置为非阻塞模式**

+ 获取fd的flags值：`int flags = fcntl(fd, F_GETFL, 0);`
+ 设置为非阻塞fd：`fcntl(fd, F_SETFL, flags | O_NONBLOCK);`
+ 设置为阻塞fd：`fcntl(fd, F_SETFL, flags & ~O_NONBLOCK);`







# 命名管道（FIFO）

前面介绍的匿名管道中，我们看到了如何使用匿名管道来在进程之间传递数据，同时也看到了这个方式的一个缺陷，就是这些进程都由一个共同的祖先进程启动，这给我们在不相关的的进程之间交换数据带来了不方便；这里将会介绍进程的另一种通信方式：`命名管道`，来解决不相关进程间的通信问题；

## **什么是命名管道**
命名管道也被称为`FIFO文件`，它是一种`特殊类型的文件`，它在文件系统中以文件名的形式存在，但是它的行为却和之前所讲的没有名字的管道（匿名管道）类似；

由于Linux中所有的事物都可被视为文件，所以对命名管道的使用也就变得与文件操作非常的统一，也使它的使用非常方便，同时我们也可以像平常的文件名一样在命令中使用；

## **创建命名管道**
我们可以使用以下两个函数之一来创建一个命名管道，原型如下：

头文件：

`sys/types.h`、`sys/stat.h`

`int mkfifo(const char *filename, mode_t mode);`

`int mknod(const char *filename, mode_t mode | S_IFIFO, (dev_t)0);`
返回值：执行成功返回0，失败返回-1，并设置errno.

这两个函数都能创建一个FIFO文件，注意是创建一个真实存在于文件系统中的文件，filename指定了文件名，而mode则指定了文件的读写权限；

或者，可以直接在shell中使用命令`mkfifo`、`mknod`来创建一个FIFO文件；
`mkfifo fifo_file`或`mknod fifo_file p`；

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>

int main(int argc, char *argv[]){
    if(argc < 2){
        fprintf(stderr, "usage: %s fifo_filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    if(mkfifo(argv[1], 0644) < 0){
        perror("mkfifo");
        exit(EXIT_FAILURE);
    }

    printf("create file \"%s\" success!\n", argv[1]);

    return 0;
}
```



```c
# root @ arch in ~/work on git:master x [17:17:34]
$ ./a.out fifo
create file "fifo" success!
```





命名管道:命名管道也被称为FIFO文件，它是一种特殊类型的文件，它在文件系统中以文件名的形式存在，但是它的行为却和之前所讲的没有名字的管道（匿名管道）类似。

创建命名管道:以下两个函数都可以用来创建命名管道(任选一个)，函数原型如下：

```c
#include <sys/types.h>  
#include <sys/stat.h>  
int mkfifo(const char *filename, mode_t mode);  
int mknod(const char *filename, mode_t mode | S_IFIFO, (dev_t)0);

// mkfifo函数，filename表示文件名，mode则表示文件的读写权限。
// mknod函数，参数中path为创建的命名管道的全路径名：mod为创建的命名管道的模式，指明其存取权限；dev为设备值，该值取决于⽂件创建的种类，它只在创建设备⽂件时才会⽤到。这两个函数调⽤成功都返回0，失败都返回－1。
```



另外，mknod属于较老的函数，而mkfifo函数使用起来更见简单规范，建议使用mkfifo函数.

这两个函数都能创建一个FIFO文件，但其实是创建了一个确实存在与文件系统中的文件，命名管道在创建后就可以使用了,命名管道和管道的使用方法基本相同,但是使用命名管道是，必须调用open函数将其打开。

**open阻塞**

调用open()打开命名管道的进程是可能会被阻塞，如果以只读(O_RDONLY)打开，调用open()函数的进程将会被阻塞直到有写方式打开管道；同样的以写的方式(O_WRONLY)打开也会阻塞直到有读方式打开管道;另外如果不希望在进行命名管道操作时发生阻塞，可以在oprn()调用中使用O_NONBLOCK标志，以关闭默认的阻塞动作。



## **访问命名管道**

**打开FIFO文件**
与打开其他文件一样，FIFO文件也可以使用open调用来打开；注意，mkfifo函数只是创建一个FIFO文件，要使用命名管道还是将其打开；

但是有一点要注意：
不能以`O_RDWR`模式打开FIFO文件进行读写操作，而其行为也未明确定义，因为如一个管道以读/写方式打开，进程就会读回自己的输出，同时我们通常使用FIFO只是为了单向的数据传递；

打开FIFO文件通常有四种方式，

- 头文件：`sys/types.h`、`sys/stat.h`、`fcntl.h`；
- `open(const char *path, O_RDONLY);`：阻塞模式打开，只读模式；
- `open(const char *path, O_RDONLY | O_NONBLOCK);`：非阻塞模式打开，只读模式；
- `open(const char *path, O_WRONLY);`：阻塞模式打开，只写模式；
- `open(const char *path, O_WRONLY | O_NONBLOCK);`：非阻塞模式打开，只写模式；
- 返回值：执行成功返回打开的文件描述符fd，执行失败返回-1，并设置errno

对于以只读方式（O_RDONLY）打开的FIFO文件，如果open调用是阻塞的（即第二个参数为O_RDONLY），除非有一个进程以写方式打开同一个FIFO，否则它不会返回；如果open调用是非阻塞的的（即第二个参数为O_RDONLY | O_NONBLOCK），则即使没有其他进程以写方式打开同一个FIFO文件，open调用将成功并立即返回；

对于以只写方式（O_WRONLY）打开的FIFO文件，如果open调用是阻塞的（即第二个参数为O_WRONLY），open调用将被阻塞，直到有一个进程以只读方式打开同一个FIFO文件为止；如果open调用是非阻塞的（即第二个参数为O_WRONLY | O_NONBLOCK），open总会立即返回，但如果没有其他进程以只读方式打开同一个FIFO文件，open调用将返回-1，并且FIFO也不会被打开；

例子：利用FIFO来在两个非亲缘关系的进程之间传输文件：
`send.c`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main(int argc, char *argv[]){
    if(argc < 3){
        fprintf(stderr, "usage: %s fifo_file filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int fifo = open(argv[1], O_WRONLY);
    if(fifo < 0){
        perror("open");
        exit(EXIT_FAILURE);
    }

    FILE *fp = fopen(argv[2], "rb");
    if(fp == NULL){
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    char buf[BUFSIZ];
    int nbuf;
    while((nbuf = fread(buf, 1, BUFSIZ, fp)) > 0){
        write(fifo, buf, nbuf);
    }

    fclose(fp);
    close(fifo);
    return 0;
}

```

`recv.c`

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>

int main(int argc, char *argv[]){
    if(argc < 3){
        fprintf(stderr, "usage: %s fifo_file filename\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    int fifo = open(argv[1], O_RDONLY);
    if(fifo < 0){
        perror("fifo");
        exit(EXIT_FAILURE);
    }

    FILE *fp = fopen(argv[2], "wb");
    if(fp == NULL){
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    char buf[BUFSIZ];
    int nbuf;
    while((nbuf = read(fifo, buf, BUFSIZ)) > 0){
        fwrite(buf, nbuf, 1, fp);
    }

    close(fifo);
    fclose(fp);
    return 0;
}

```

```c
# root @ arch in ~/work on git:master x [18:36:19]
$ gcc -o send send.c

# root @ arch in ~/work on git:master x [18:36:22]
$ gcc -o recv recv.c

# root @ arch in ~/work on git:master x [18:36:26]
$ ll
total 32K
pr--r--r-- 1 root root    0 Aug 13 18:34 fifo
-rwxr-xr-x 1 root root 8.8K Aug 13 18:36 recv
-rw-r--r-- 1 root root  727 Aug 13 18:34 recv.c
-rwxr-xr-x 1 root root 8.8K Aug 13 18:36 send
-rw-r--r-- 1 root root  727 Aug 13 18:32 send.c

# root @ arch in ~/work on git:master x [18:36:30]
$ ./send fifo /etc/sysctl.conf

# root @ arch in ~/work on git:master x [18:35:08]
$ ./recv fifo sysctl.conf

# root @ arch in ~/work on git:master x [18:36:48]
$ ll
total 36K
pr--r--r-- 1 root root    0 Aug 13 18:36 fifo
-rwxr-xr-x 1 root root 8.8K Aug 13 18:36 recv
-rw-r--r-- 1 root root  727 Aug 13 18:34 recv.c
-rwxr-xr-x 1 root root 8.8K Aug 13 18:36 send
-rw-r--r-- 1 root root  727 Aug 13 18:32 send.c
-rw-r--r-- 1 root root  803 Aug 13 18:36 sysctl.conf

# root @ arch in ~/work on git:master x [18:36:50]
$ cat sysctl.conf
net.ipv4.ip_forward = 1
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_tw_reuse = 1
#net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_fin_timeout = 3
net.ipv4.ip_local_port_range = 10000 65535
net.ipv4.tcp_max_tw_buckets = 5000
net.ipv4.tcp_max_syn_backlog = 10240
net.core.netdev_max_backlog = 10240
net.core.somaxconn = 10240
net.ipv4.tcp_syn_retries = 2
net.ipv4.tcp_synack_retries = 2
net.ipv4.tcp_max_orphans = 3276800
net.ipv4.tcp_keepalive_time = 120
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 3
net.core.rmem_default = 8388608
net.core.wmem_default = 8388608
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.ipv4.tcp_rmem = 32768 436600 873200
net.ipv4.tcp_wmem = 8192 436600 873200
net.ipv4.tcp_mem = 398458 448266 498073
net.ipv4.tcp_fastopen = 3
fs.file-max = 500000000

```









## **命名管道的安全问题**
前面的例子是两个进程之间的通信问题，也就是说，一个进程向FIFO文件写数据，而另一个进程则在FIFO文件中读取数据；
试想这样一个问题，只使用一个FIFO文件，如果有多个进程同时向同一个FIFO文件写数据，而只有一个读FIFO进程在同一个FIFO文件中读取数据时，会发生怎么样的情况呢？
会发生数据块的相互交错是很正常的，而且个人认为多个不同进程向一个FIFO读进程发送数据是很普通的情况；

为了解决这一问题，就是让写操作的原子化：
FIFO写操作的原子化同pipe()匿名管道，即：每次写入的数据小于等于`PIPE_BUF`的大小，即可保证要么一次性全部写入，要么一个字节也不写入；

**匿名管道与命名管道**
使用匿名管道，通信的进程之间需要一个父子关系，通信的两个进程一定是由一个共同的祖先进程启动；但是匿名管道没有上面说到的数据交叉的问题；

与使用匿名管道相比，我们可以看到send和recv这两个进程是没有什么必然的联系的，如果硬要说他们具有某种联系，就只能说是它们都访问同一个FIFO文件；
它解决了之前在匿名管道中出现的通信的两个进程一定是由一个共同的祖先进程启动的问题；但是为了数据的安全，我们很多时候要采用阻塞的FIFO，让写操作变成原子操作；





下面来看一个简单的例子1：
**write端**

```c
#include<stdio.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<unistd.h>
#include<fcntl.h>
#include<string.h>
 
#define PATH "./myfifo"
#define SIZE 200
 
int main()
{
    int a=mkfifo(PATH,0666|S_IFIFO);
    if(a==-1)
    {
       perror("mkfifo error!");
       exit(0);
    }
    int fd=open(PATH,O_WRONLY);
    if(fd < 0)
    {
        printf("open file error!\n");
        return 0;
    }
    char buffer[SIZE];
    memset(buffer,'\0',sizeof(buffer));
    while(1)
    {
        read(0,buffer,sizeof(buffer));
        int b=write(fd,buffer,strlen(buffer)-1);
        buf[b]='\0';
        if(b < 0)
        {
          printf("wirte error!\n");
          break;
        }
        if(strncmp(buffer,"end",3)==0)
        {
           break;
        }
    }
    close(fd);
    return 0;
}
```



**read端**

```c
#include<stdio.h>
#include<sys/types.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<string.h>
#include<unistd.h>
 
#define PATH "./myfifo"
#define SIZE 200
 
int main()
{
    int fd =open(PATH,O_RDONLY);
    if(fd<0)
    {
       printf("open file error!\n");
       return 0;
    }
    char buffer[SIZE];
    memset(buffer,'\0',sizeof(buffer));
    while(1)
    {
       int a=read(fd,buffer,sizeof(buffer));
       if(a<=0)
       {
          printf("read end or error!\n");
          break;
       }
       printf("%s\n",buffer);
       if(strncmp(buffer,"end",3)==0)
        {
          break;
        }
    }
    close(fd);
    return 0;
}
```

先运行write端，再运行read端，在write端输入数据，就可以在read端读出数据，直到输入end结束通信。





# 信号 （signal）













##   signal 函数

我们使用过windows的都知道，当一个程序被卡死的时候不管怎样都没反应，这样我们就可以打开任务管理器直接强制性的结束这个进程，这个方法的实现就是和Linux上通过生成信号和捕获信号来实现相似的，运行过程中进程捕获到这些信号做出相应的操作使最终被终止。

信号的主要来源是分为两部分，一部分是硬件来源，一部分是软件来源；进程在实际中可以用三种方式来响应一个信号：一是忽略信号，不对信号做任何操作，其中有两个信号是不能别忽略的分别是SIGKILL和SIGSTOP。二是捕捉信号，定义信号处理函数，当信号来到时做出响应的处理。三是执行缺省操作，Linux对每种信号都规定了默认操作。注意，进程对实时信号的缺省反应是立即终止。

发送信号的函数有很多，主要使用的有：`kill()、raise()、abort()、alarm()`。

先来熟悉下kill函数，进程可以通过kill()函数向包括它本身在内的其它进程发送一个信号，如果程序没有发送这个信号的权限，对kill函数的调用将会失败，失败的原因通常是由于目标进程由另一个用户所拥有。

kill函数的原型为：

```c
#include<sys/types.h>
#include<signal.h>
int kill(pid_t pid,int sig);
```

它的作用是把信号sig发送给进程号为pid的进程，成功时返回0。kill调用失败返回-1，调用失败通常有三大原因：

- 1、给定的信号无效
- 2、发送权限不够
- 3、目标进程不存在

pid 参数标识一个或多个目标进程，而 sig 则指定了要发送的信号。如何解释 pid，要视以 下 4 种情况而定。 

+ 如果 pid 大于 0，那么会发送信号给由 pid 指定的进程。 
+ 如果 pid 等于 0，那么会发送信号给与调用进程同组的每个进程，包括调用进程自身。 （SUSv3 声明，除去“一组未予明确的系统进程”1 之外，应将信号发送给同一进程组 中的所有进程，且这一排除条件同样适用于余下的两种情况。） 
+ 如果 pid 小于−1，那么会向组 ID 等于该 pid 绝对值的进程组内所有下属进程发送 信号。向一个进程组的所有进程发送信号在 shell 作业控制中有特殊用途（参见 34.7 节）。 
+ 如果 pid 等于−1，那么信号的发送范围是：调用进程有权将信号发往的每个目标进程， 除去 init（进程 ID 为 1）和调用进程自身。如果特权级进程发起这一调用，那么会发 送信号给系统中的所有进程，上述两个进程除外。显而易见，有时也将这种信号发送 方式称之为广播信号。（SUSv3 并未要求将调用进程排除在信号的接收范围之外，Linux 此处所遵循的是 BSD 系统的语义。） 

如果并无进程与指定的 pid 相匹配，那么 kill()调用失败，同时将 errno 置为 ESRCH（“查无 此进程”）。

有时，进程需要向自身发送信号 。raise()函数就执行了这一任务。

```c
#include<signal.h>
int raise(int sig);
```

使用a l a r m函数可以设置一个时间值(闹钟时间)，在将来的某个时刻该时间值会被超过。当 所设置的时间值被超过后，产生SIGALRM信号。如果不忽略或不捕捉此信号，则其默认动作 是终止该进程。	

```c
#include <unistd.h>
unsigned int alarm(unsigned int seconds) ;
```

其中，参数seconds的值是秒数，经过了指定的seconds秒后会产生信号SIGALRM。要了解的是， 经过了指定秒后，信号由内核产生，由于进程调度的延迟，进程得到控制能够处理该信号还需 一段时间。





还有一个非常重要的函数，信号处理signal函数。程序可以用signal函数来处理指定的信号，主要通过恢复和忽略默认行为来操作。signal函数原型如下：

```javascript
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

UNIX 系统提供了两种方法来改变信号处置：signal()和 sigaction()。本节描述的 signal()系统 调用，是设置信号处置的原始 API，所提供的接口比 sigaction()简单。另一方面，sigaction() 提供了 signal()所不具备的功能。进一步而言，signal()的行为在不同 UNIX 实现间存在差异，这也意味着对可移植性有所追求的程序绝不能使用此调用来建立信号处理器函数。故此， sigaction()是建立信号处理器的首选 API（强力推荐）

调用 pause()将暂停进程的执行，直至信号处理器函数中断该调用为止（或者直至一个未 处理信号终止进程为止）。

```c
#include<signal.h>

int pause(void);
```

处理信号时，pause()遭到中断，并总是返回−1，并将 errno 置为 EINTR。



函数 abort()终止其调用进程，并生成核心转储。

```c
#include <stdlib.h>
void abort(void);
```

函数 abort()通过产生 SIGABRT 信号来终止调用进程。对 SIGABRT 的默认动作是产 生核心转储文件并终止进程。调试器可以利用核心转储文件来检测调用 abort()时的程序 状态。 SUSv3 要求，无论阻塞或者忽略 SIGABRT 信号，abort()调用均不受影响。同时规定，除 非进程捕获 SIGABRT 信号后信号处理器函数尚未返回，否则 abort()必须终止进程。后一句话 值得三思。21.2 节所描述的信号处理器函数终止方法中，与此相关的就是使用非本地跳转退出处理器函数。这一做法将抵消 abort()的效果。否则，abort()将总是终止进程。在大多数实现 中，终止时可确保发生如下事件：若进程在发出一次 SIGABRT 信号后仍未终止（即，处理器 捕获信号并返回，以便恢复执行 abort()），则 abort()会将对 SIGABRT 信号的处理重置为 SIG_DFL，并再度发出 SIGABRT 信号，从而确保将进程杀死。 如果 abort()成功终止了进程，那么还将刷新 stdio 流并将其关闭。



```c
void (*signal(int sig, void (*func)(int)))(int);
```

函数说明：signal () 会依参数 signum 指定的信号编号来设置该信号的处理函数。当指定的信号到达时就会跳转到参数 handler 指定的函数执行。如果参数 handler 不是函数指针，则必须是下列两个常数之一：

1、SIG_IGN 忽略参数 signum 指定的信号.

2、SIG_DFL 将参数 signum 指定的信号重设为核心预设的信号处理方式.

返回值：该函数返回信号处理程序之前的值，当发生错误时返回 SIG_ERR。

+ 参数说明：

  + **sig** -- 在信号处理程序中作为变量使用的信号码，它可以取除 SIGKILL 和 SIGSTOP 之外的任意信号。下面是一些重要的标准信号常量：

    |   宏    | 信号                                                         |
    | :-----: | :----------------------------------------------------------- |
    | SIGABRT | (Signal Abort) 程序异常终止。                                |
    | SIGFPE  | (Signal Floating-Point Exception) 算术运算出错，如除数为 0 或溢出（不一定是浮点运算）。 |
    | SIGILL  | (Signal Illegal Instruction) 非法函数映象，如非法指令，通常是由于代码中的某个变体或者尝试执行数据导致的。 |
    | SIGINT  | (Signal Interrupt) 中断信号，如 ctrl-C，通常由用户生成。     |
    | SIGSEGV | (Signal Segmentation Violation) 非法访问存储器，如访问不存在的内存单元。 |
    | SIGTERM | (Signal Terminate) 发送给本程序的终止请求信号。              |

  + **func** -- 一个指向函数的指针。第二个参数则是一个函数指针，该函数无返回值，且包含一个 int 型的参数，表明了当产生信号时，函数指针指向的函数将会被调用。它可以是一个由程序定义的函数，也可以是下面预定义函数之一：

    | SIG_DFL | 默认的信号处理程序。 |
    | ------- | -------------------- |
    | SIG_IGN | 忽视信号。           |



>  附加说明：
>
>  >  在信号发生跳转到自定的 handler 处理函数执行后，系统会自动将此处理函数换回原来系统预设的处理方式，如果要改变此操作请改用 sigaction ().



> 实例
>
> ```c
> #include <stdio.h>
> #include <unistd.h>
> #include <stdlib.h>
> #include <signal.h>
> 
> void sighandler(int);
> 
> int main()
> {
>  signal(SIGINT, sighandler);
> 
> while(1)
> {
>     printf("开始休眠一秒钟...\n");
>     sleep(1);
> }
>  return(0);
> }
> 
> void sighandler(int signum)
> {
>  printf("捕获信号 %d，跳出...\n", signum);
>  exit(1);
> }
> ```
>
> 让我们编译并运行上面的程序，这将产生以下结果，且程序会进入无限循环，需使用 CTRL + C 键跳出程序。
>
> ```bash
> 开始休眠一秒钟...
> 开始休眠一秒钟...
> 开始休眠一秒钟...
> 开始休眠一秒钟...
> 开始休眠一秒钟...
> 捕获信号 2，跳出...
> ```









##  sigaction函数

除去 signal()之外，sigaction()系统调用是设置信号处置的另一选择。虽然 sigaction()的用 法比之 signal()更为复杂，但作为回报，也更具灵活性。尤其是，sigaction()允许在获取信号处置 的同时无需将其改变，并且，还可设置各种属性对调用信号处理器程序时的行为施以更加精 准的控制。此外， 在建立信号处理器程序时，sigaction()较之 signal()函数可移 植性更佳。

 signal 函数的使用方法简单，但并不属于 POSIX 标准，在各类 UNIX 平台上的实现不尽相同，因此其用途受到了一定的限制。而 POSIX 标准定义的信号处理接口是 sigaction 函数，其接口头文件及原型如下：

```c
// sigaction 函数的功能是检查或修改与指定信号相关联的处理动作（可同时两种操作）
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
```

+ signum：要操作的信号，signum 参数指出要捕获的信号类型，可以为除 SIGKILL 及 SIGSTOP 外的任何一个特定有效的信号（为这两个信号定义自己的处理函数，将导致信号安装错误），有关信号可以查看[信号1](#信号1)、[信号2](#信号2)，SIGNUM有以下：

  ```bash
  # junjie @ Ubuntu in ~/公共的/c文件/计算机网络 [日期: 周二 3月 16日, 时间:14:23:28]
  $ kill -l
   1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
   6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
  11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
  16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
  21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
  26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
  31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
  38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
  43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
  48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
  53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
  58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
  63) SIGRTMAX-1  64) SIGRTMAX
  ```

  列表中，编号为 1~31 的信号为传统 UNIX 支持的信号，是不可靠信号（非实时的），编号为 32~63 的信号是后来扩充的，称做可靠信号（实时信号）。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后者不会。

  + 1）SIGHUP：本信号在用户终端连接（正常或非正常）结束时发出，通常是在终端的控制进程结束的，通知同一 session 内的各个作用，这是它们与控制终端不再关联。

    登录 Linux 时，系统会分配给登录用户一个终端（Session）。在这个终端运行的所有程序，包括前台进程组和后台进程组，一般都属于这个 Session。当用户退出 Linux 登录时，前台进程和后台有对终端输出的进程将会收到 SIGHUP 信号，这个信号的默认操作为终止进程，因此前台进程组和后台有终端输出的进程就会终止。不过可以捕获这个信号，比如 wget 能捕获 SIGHUP 信号，并忽略它，这样就算退出了 Linux 登录，wget 也能继续下载。

    此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。

  + 2） SIGINT：程序终止 (interrupt) 信号，在用户键入 INTR 字符 (通常是 Ctrl-C) 时发出，用于通知前台进程组终止进程。

  + 3）SIGQUIT：和 SIGINT 类似，但由 QUIT 字符 (通常是 Ctrl-/) 来控制。进程在因收到 SIGQUIT 退出时会产生 core 文件，在这个意义上类似于一个程序错误信号。

  + 4） SIGILL：执行了非法指令。通常是因为可执行文件本身出现错误，或者试图执行数据段。堆栈溢出时也有可能产生这个信号。
  + 5) SIGTRAP：由断点指令或其它 trap 指令产生。由 debugger 使用。
  + 6) SIGABRT：调用 abort 函数生成的信号。

  + 7) SIGBUS：非法地址，包括内存地址对齐 (alignment) 出错。比如访问一个四个字长的整数，但其地址不是 4 的倍数。它与 SIGSEGV 的区别在于后者是由于对合法存储地址的非法访问触发的 (如访问不属于自己存储空间或只读存储空间)。

  + 8) SIGFPE：在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为 0 等其它所有的算术的错误。

  +   9) SIGKILL：用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送这个信号。

  + 10) SIGUSR1：留给用户使用

  + 11) SIGSEGV：试图访问未分配给自己的内存，或试图往没有写权限的内存地址写数据.

  + 12) SIGUSR2：留给用户使用

  + 13) SIGPIPE：管道破裂。这个信号通常在进程间通信产生，比如采用 FIFO (管道) 通信的两个进程，读管道没打开或者意外终止就往管道写，写进程会收到 SIGPIPE 信号。此外用 Socket 通信的两个进程，写进程在写 Socket 的时候，读进程已经终止。

  + 14) SIGALRM：时钟定时信号，计算的是实际的时间或时钟时间. alarm 函数使用该信号.

  + 15) SIGTERM：程序结束 (terminate) 信号，与 SIGKILL 不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出，shell 命令 kill 缺省产生这个信号。如果进程终止不了，我们才会尝试 SIGKILL。

  + 17) SIGCHLD：子进程结束时，父进程会收到这个信号。

    如果父进程没有处理这个信号，也没有等待 (wait) 子进程，子进程虽然终止，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情况我们应该避免 (父进程或者忽略 SIGCHILD 信号，或者捕捉它，或者 wait 它派生的子进程，或者父进程先终止，这时子进程的终止自动由 init 进程来接管)。

  + 18) SIGCONT：让一个停止 (stopped) 的进程继续执行。本信号不能被阻塞。可以用一个 handler 来让程序在由 stopped 状态变为继续执行时完成特定的工作。例如，重新显示提示符

  + 19) SIGSTOP：停止 (stopped) 进程的执行。注意它和 terminate 以及 interrupt 的区别：该进程还未结束，只是暂停执行。本信号不能被阻塞，处理或忽略.

  + 20) SIGTSTP：停止进程的运行，但该信号可以被处理和忽略。用户键入 SUSP 字符时 (通常是 Ctrl-Z) 发出这个信号

  + 21) SIGTTIN：当后台作业要从用户终端读数据时，该作业中的所有进程会收到 SIGTTIN 信号。缺省时这些进程会停止执行.

  + 22) SIGTTOU：类似于 SIGTTIN, 但在写终端 (或修改终端模式) 时收到.

  + 23) SIGURG：有 "紧急" 数据或 out-of-band 数据到达 socket 时产生.

  + 24) SIGXCPU：超过 CPU 时间资源限制。这个限制可以由 getrlimit/setrlimit 来读取 / 改变。

  + 25) SIGXFSZ：当进程企图扩大文件以至于超过文件大小资源限制。

  + 26) SIGVTALRM：虚拟时钟信号。类似于 SIGALRM, 但是计算的是该进程占用的 CPU 时间.

  + 27) SIGPROF：类似于 SIGALRM/SIGVTALRM, 但包括该进程用的 CPU 时间以及系统调用的时间.

  + 28) SIGWINCH：窗口大小改变时发出.

  + 29) SIGIO：文件描述符准备就绪，可以开始进行输入 / 输出操作.

  + 30) SIGPWR：Powerfailure

  + 31) SIGSYS：非法的系统调用。

    在以上列出的信号中，程序不可捕获、阻塞或忽略的信号有：SIGKILL,SIGSTOP
    不能恢复至默认动作的信号有：SIGILL,SIGTRAP
    默认会导致进程流产的信号有：SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGIOT, SIGQUIT, SIGSEGV, SIGTRAP, SIGXCPU, SIGXFSZ
    默认会导致进程退出的信号有：SIGALRM, SIGHUP, SIGINT, SIGKILL, SIGPIPE, SIGPOLL, SIGPROF, SIGSYS, SIGTERM, SIGUSR1, SIGUSR2, SIGVTALRM
    默认会导致进程停止的信号有：SIGSTOP,SIGTSTP,SIGTTIN,SIGTTOU
    默认进程忽略的信号有：SIGCHLD,SIGPWR,SIGURG,SIGWINCH

+ act：要设置的对信号的新处理方式。

+ oldact：原来对信号的处理方式。

+ 返回值：0 表示成功，-1 表示有错误发生。

  错误代码：
  
  + EINVAL 参数 signum 不合法，或是企图拦截 SIGKILL/SIGSTOPSIGKILL 信号。
  + EFAULT 参数 act, oldact 指针地址无法存取。
  + EINTR 此调用被中断。

act 参数是一枚指针，指向描述信号新处置的数据结构。如果仅对信号的现有处置感兴趣， 那么可将该参数指定为 NULL。oldact 参数是指向同一结构类型的指针，用来返回之前信号处 置的相关信息。如果无意获取此类信息，那么可将该参数指定为 NULL。act 和 oldact 所指向 的结构类型如下所示：

```c
struct sigaction {
    void (*sa_handler)(int);
    void (*sa_sigaction)(int, siginfo_t *, void *);
    sigset_t sa_mask;
    int sa_flags;
    void (*sa_restorer)(void);
}
```

+ **成员 sa_handler 是一个函数指针**，其含义与 signal 函数中的信号处理函数类似，sa_handler 字段对应于 signal()的 handler 参数。其所指定的值为信号处理器函数的地址，亦 或是常量 SIG_IGN、SIG_DFL 之一。仅当 sa_handler 是信号处理程序的地址时，亦即 sa_handler 的取值在 SIG_IGN 和 SIG_DFL 之外，才会对 sa_mask 和 sa_flags 字段（稍后讨论）加以处理。
+ **成员 sa_sigaction 则是另一个信号处理函数**，它有三个参数，可以获得关于信号的更详细的信息。当 sa_flags 成员的值包含了 SA_SIGINFO 标志时，系统将使用 sa_sigaction 函数作为信号处理函数，否则使用 sa_handler 作为信号处理函数。**在某些系统中，成员 sa_handler 与 sa_sigaction 被放在联合体中，因此使用时不要同时设置。**
+ **成员 sa_mask 用来指定在信号处理函数执行期间需要被屏蔽的信号**，特别是当某个信号被处理时，它自身会被自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生，sa_mask 字段定义了一组信号，在调用由 sa_handler 所定义的处理器程序时将阻塞该组信 号。当调用信号处理器程序时，会在调用信号处理器之前，将该组信号中当前未处于进程掩 码之列的任何信号自动添加到进程掩码中。这些信号将保留在进程掩码中，直至信号处理器 函数返回，届时将自动删除这些信号。利用 sa_mask 字段可指定一组信号，不允许它们中断 此处理器程序的执行。此外，引发对处理器程序调用的信号将自动添加到进程信号掩码中。 这意味着，当正在执行处理器程序时，如果同一个信号实例第二次抵达，信号处理器程序将 不会递归中断自己。由于不会对遭阻塞的信号进行排队处理，如果在处理器程序执行过程中
+ **成员 sa_flags 用于指定信号处理的行为**，是一个位掩码，指定用于控制信号处理过程的各种选项，它可以是一下值的 “按位或” 组合：
  + SA_RESTART：使被信号打断的系统调用自动重新发起。
  +  SA_NOCLDSTOP：使父进程在它的子进程暂停或继续运行时不会收到 SIGCHLD 信号。
  + SA_NOCLDWAIT：使父进程在它的子进程退出时不会收到 SIGCHLD 信号，这时子进程如果退出也不会成为僵尸进程。
  + SA_NODEFER：使对信号的屏蔽无效，即在信号处理函数执行期间仍能发出这个信号，一般情况下， 当信号处理函数运行时，内核将阻塞该给定信号。但是如果设置了 SA_NODEFER 标记， 那么在该信号处理函数运行时，内核将不会阻塞该信号；
  + SA_ONESHOT/SA_RESETHAND：信号处理之后重新设置为默认的处理方式，当捕获该信号时，会在调用处理器函数之前将信号处置重置为默认值（即 SIG_DFL）（默 认情况下，信号处理器函数保持建立状态，直至进一步调用 sigaction()将其显式解除。）。
  + SA_SIGINFO：使用 sa_sigaction 成员而不是 sa_handler 作为信号处理函数。
+ **成员 re_restorer 则是一个已经废弃的数据域**，不要使用。

与sigaction函数相关的函数还有：

```c
#include <signal.h>
sigemptyset (sigset_t *set)
//初始化由 set 指定的信号集，信号集里面的所有信号被清空；错误代码：EFAULT 参数 set 指针地址无法存取。

sigfillset (sigset_t *set)
//调用该函数后，set 指向的信号集中将包含 linux 支持的 64 种信号；

sigaddset (sigset_t *set, int signum)
//在 set 指向的信号集中加入 signum 信号；
//错误代码：
//1、EFAULT 参数 set 指针地址无法存取。
//2、EINVAL 参数 signum 非合法的信号编号。


sigdelset (sigset_t *set, int signum)
//在 set 指向的信号集中删除 signum 信号；

sigismember (const sigset_t *set, int signum)
//判定信号 signum 是否在 set 指向的信号集中。

int sigandset(sigset_t *dest, sigset_t *left, sigset_t *right);
// 将left集合和right集合交集置于dest集合

int sigandset(sigset_t *dest, sigset_t *left, sigset_t *right);
// 将left集合和right集合并集置于dest集合

// 以上函数执行成功则返回 0, 如果有错误则返回 - 1.

int sigisemptyset(const sigset_t *set);
// 若set集合内未包含信号，则sigisemptyset返回true

// sigpending返回对于调用进程被阻塞不能递送和当前未决的信号集。该信号集通过 set参数返回。
int sigpending(sigset_t *set);


```

内核会为每个进程维护一个信号掩码，即一组信号，并将阻塞其针对该进程的传递。如果将遭阻塞的信号发送给某进程，那么对该信号的传递将延后，直至从进程信号掩码中移除 该信号，从而解除阻塞为止。（信号掩码实际属于线程属性，在多线程进程 中，每个线程都可使用 pthread_sigmask()函数来独立检查和修改其信号掩码。） 向信号掩码中添加一个信号，有如下几种方式。 

+ 当调用信号处理器程序时，可将引发调用的信号自动添加到信号掩码中。是否发生这 一情况，要视 sigaction()函数在安装信号处理器程序时所使用的标志而定。 
+ 使用 sigaction()函数建立信号处理器程序时，可以指定一组额外信号，当调用该处理 器程序时会将其阻塞。 
+  使用 sigprocmask()系统调用，随时可以显式向信号掩码中添加或移除信号。 现在先来讨论 sigprocmask()函数。

```c
#include<signal.h>

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

使用 sigprocmask()函数既可修改进程的信号掩码，又可获取现有掩码，或者两重功效兼 具。how 参数指定了 sigprocmask()函数想给信号掩码带来的变化。 +

+ SIG_BLOCK 将 set 指向信号集内的指定信号添加到信号掩码中。换言之，将信号掩码设置为其当前值 和 set 的并集。 
+ SIG_UNBLOCK 将 set 指向信号集中的信号从信号掩码中移除。即使要解除阻塞的信号当前并未处于阻塞 状态，也不会返回错误。 
+ SIG_SETMASK 将 set 指向的信号集赋给信号掩码。 

上述各种情况下，若 oldset 参数不为空，则其指向一个 sigset_t 结构缓冲区，用于返回之 前的信号掩码。

 如果想获取信号掩码而又对其不作改动，那么可将 set 参数指定为空，这时将忽略 how 参数。



**总结**：信号是发生某种事件的通知机制，可以由内核、另一进程或进程自身发送给进程。存在 一系列的标准信号类型，每种都有唯一的编号和目的。 信号传递通常是异步行为，这意味着信号中断进程执行的位置是不可预测的。有时（比如， 硬件产生的信号），信号也可同步传递，这意味着在程序执行的某一点可以预期并重现信号的传递。 默认情况下，要么忽略信号，要么终止进程（生成或者不生成核心转储文件），要么停止一个 正在运行的进程，要么重启一个已停止的进程。特定的默认行为取决于信号类型。此外，程序可 以使用 signal()或者 sigaction()来显式忽略一个信号，或者建立一个由程序员自定义的信号处理器 程序，以供信号到达时调用。出于可移植性考虑，最好使用 sigaction()来建立信号处理器函数。 一个（具有适当权限的）进程可以使用 kill()向另一进程发送信号。发送空信号（0）是判 定特定进程 ID 是否在用的方式之一。 每个进程都具有一个信号掩码，代表当前传递遭到阻塞的一组信号。使用 sigprocmask() 可从信号掩码中添加或者移除信号。 如果接收的信号当前遭到阻塞，那么该信号将保持等待状态，直至解除对其阻塞。系统 不会对标准信号进行排队处理，也就是说，将信号标记为等待状态（以及后续的传递）只会 发生一次。进程能够使用 sigpending()系统调用来获取等待信号集（用以描述多个不同信号的 数据结构）。 与 signal()相比，sigaction()系统调用在设置信号处置方面提供了更多控制，且更具灵活性。 首先，可以指定一组调用处理器函数时将阻塞的额外信号。此外，可以使用各种标志来控制调 用信号处理器时所发生的行为。例如，启用某些标志即可选择旧有的不可靠信号语义（不阻塞 引发处理器调用的信号，在调用信号处理器之前就将信号处置重置为默认值）。 借助于 pause()，进程可暂停执行，直至信号到达为止。



> [实例1：](https://blog.csdn.net/weibo1230123/article/details/81411827)

```c
//实例1

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>

int main()
{
    struct sigaction newact,oldact;

    /* 设置信号忽略 */
    newact.sa_handler = SIG_IGN; //这个地方也可以是函数
    sigemptyset(&newact.sa_mask);
    newact.sa_flags = 0;
    int count = 0;
    pid_t pid = 0;

    sigaction(SIGINT,&newact,&oldact);//原来的备份到oldact里面

    pid = fork();
    if(pid == 0)
    {
        while(1)
        {
            printf("I'm child gaga.......\n");
            sleep(1);
        }
        return 0;
    }

    while(1)
    {
        if(count++ > 3)
        {
            sigaction(SIGINT,&oldact,NULL);  //备份回来
            printf("pid = %d\n",pid);
            kill(pid,SIGKILL); //父进程发信号，来杀死子进程
        }

        printf("I am father .......... hahaha\n");
        sleep(1);
    }

    return 0;
}
```



> [实例2](https://blog.csdn.net/weibo1230123/article/details/81411827)

```c
// 实例2
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
void show_handler(int sig)
{
    printf("I got signal %d\n", sig);
    int i;
    for(i = 0; i < 5; i++)
   {
        printf("i = %d\n", i);
        sleep(1);
    }
}

int main(void)
{
    int i = 0;
    struct sigaction act, oldact;
    act.sa_handler = show_handler;
    sigaddset(&act.sa_mask, SIGQUIT);           //见注(1)
    act.sa_flags = SA_RESETHAND | SA_NODEFER;   //见注(2)
    //act.sa_flags = 0;                         //见注(3)

    sigaction(SIGINT, &act, &oldact);
    while(1)
   {
        sleep(1);
        printf("sleeping %d\n", i);
        i++;
    }
}
```

注：

(1) 如果在信号 SIGINT (Ctrl + c) 的信号处理函数 show_handler 执行过程中，本进程收到信号 SIGQUIT (Crt+\\)，将阻塞该信号，直到 show_handler 执行结束才会处理信号 SIGQUIT。

(2) SA_NODEFER 一般情况下， 当信号处理函数运行时，内核将阻塞 < 该给定信号 -- SIGINT>。但是如果设置了 SA_NODEFER 标记， 那么在该信号处理函数运行时，内核将不会阻塞该信号。 SA_NODEFER 是这个标记的正式的 POSIX 名字 (还有一个名字 SA_NOMASK，为了软件的可移植性，一般不用这个名字) 。

 SA_RESETHAND 当调用信号处理函数时，将信号的处理函数重置为缺省值。 SA_RESETHAND 是这个标记的正式的 POSIX 名字 (还有一个名字 SA_ONESHOT，为了软件的可移植性，一般不用这个名字)

(3) 如果不需要重置该给定信号的处理函数为缺省值；并且不需要阻塞该给定信号 (无须设置 sa_flags 标志)，那么必须将 sa_flags 清零，否则运行将会产生段错误。但是 sa_flags 清零后可能会造成信号丢失！



输出如下：

```bash
# junjie @ Ubuntu in ~/公共的/c文件/systemlib [日期: 周二 3月 16日, 时间:09:50:59]
$ ./test
sleeping 0
sleeping 1
sleeping 2
sleeping 3
sleeping 4
sleeping 5
sleeping 6
sleeping 7
sleeping 8
sleeping 9
sleeping 10
sleeping 11
sleeping 12
按下<ctrl + c> got signal 2
i = 0
i = 1
i = 2
i = 3
i = 4
sleeping 13
sleeping 14
sleeping 15
sleeping 16
sleeping 17
sleeping 18
sleeping 19
sleeping 20
sleeping 21
sleeping 22
按下<ctrl + c>
```





> [实例3](https://blog.csdn.net/weibo1230123/article/details/81411827)

```c
//实例3

#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>

static void sig_usr(int signum)
{
    if(signum == SIGUSR1)
    {
        printf("SIGUSR1 received\n");
    }
    else if(signum == SIGUSR2)
    {
        printf("SIGUSR2 received\n");
    }
    else
    {
        printf("signal %d received\n", signum);
    }
}

int main(void)
{
    char buf[512];
    int  n;
    struct sigaction sa_usr;
    sa_usr.sa_flags = 0;
    sa_usr.sa_handler = sig_usr;   //信号处理函数

    sigaction(SIGUSR1, &sa_usr, NULL);
    sigaction(SIGUSR2, &sa_usr, NULL);

    printf("My PID is %d\n", getpid());

    while(1)
    {
        if((n = read(STDIN_FILENO, buf, 511)) == -1)
        {
            if(errno == EINTR)
            {
                printf("read is interrupted by signal\n");
            }
        }
        else
        {
            buf[n] = '\0';
            printf("%d bytes read: %s\n", n, buf);
        }
    }

    return 0;
}
```

 在这个例程中使用 sigaction 函数为 SIGUSR1 和 SIGUSR2 信号注册了处理函数，然后从标准输入读入字符。程序运行后首先输出自己的 PID，如：

```bash
My PID is 5904
```


 这时如果从另外一个终端向进程发送 SIGUSR1 或 SIGUSR2 信号，用类似如下的命令：kill -USR1 5904

 则程序将继续输出如下内容：

```bash
 SIGUSR1 received
 read is interrupted by signal
```



 这说明用 sigaction 注册信号处理函数时，不会自动重新发起被信号打断的系统调用。如果需要自动重新发起，则要设置 SA_RESTART 标志，比如在上述例程中可以进行类似一下的设置：sa_usr.sa_flags = SA_RESTART。



> [实例4](http://c.biancheng.net/cpp/html/1142.html)

```c
// 范例4
#include<stdio.h>
#include<stdlib.h>
#include <unistd.h>
#include <signal.h>
void show_handler(struct sigaction * act)
{
    switch(act->sa_flags)
    {
        case SIG_DFL:
        printf("Default action\n");
        break;
        case SIG_IGN:
        printf("Ignore the signal\n");
        break;
        default:
        printf("0x%x\n", act->sa_handler);
    }
}

int main()
{
    int i;
    struct sigaction act, oldact;
    act.sa_handler = show_handler;
    act.sa_flags = SA_ONESHOT|SA_NOMASK;
    sigaction(SIGUSR1, &act, &oldact);
    for(i = 5; i < 15; i++)
    {
        printf("sa_handler of signal %2d =", i);
        sigaction(i, NULL, &oldact);
    }
    
    return 0;
}
```

执行：

```bash
sa_handler of signal 5 = Default action
sa_handler of signal 6 = Default action
sa_handler of signal 7 = Default action
sa_handler of signal 8 = Default action
sa_handler of signal 9 = Default action
sa_handler of signal 10 = 0x8048400
sa_handler of signal 11 = Default
action sa_handler of signal 12 = Default action
sa_handler of signal 13 = Default action
sa_handler of signal 14 = Default action
```



> [实例5](https://ixyzero.com/blog/archives/3431.html)

```c
#include <stdio.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
static void sig_usr(int signum)
{
    if(signum == SIGUSR1)
    {
        printf("SIGUSR1 received\n");
    }
    else if(signum == SIGUSR2)
    {
        printf("SIGUSR2 received\n");
    }
    else
    {
        printf("signal %d received\n", signum);
    }
}
int main(void)
{
    char buf[512];
    int  n;
/*
    sigset_t mask;
    sigfillset(&mask); //将参数 mask 信号集初始化，然后把所有的信号加入到此信号集里，在这里表示屏蔽所有信号
    sigdelset(&mask, SIGUSR1); //删除set中的SIGUSR1信号，即——不屏蔽SIGUSR1信号
    sigdelset(&mask, SIGUSR2); //不屏蔽SIGUSR2信号
    sigprocmask(SIG_SETMASK, &mask, NULL); //参数SIG_SETMASK指定屏蔽mask中包含的信号集
*/
    struct sigaction sa_usr;
    sa_usr.sa_flags = 0;
    //sa_usr.sa_flags = SA_RESTART;
    sa_usr.sa_handler = sig_usr;   //信号处理函数
    sigaction(SIGUSR1, &sa_usr, NULL);
    sigaction(SIGUSR2, &sa_usr, NULL);
    printf("My PID is %d\n", getpid());
    while(1)
    {
        if((n = read(STDIN_FILENO, buf, 511)) == -1)
        {
            if(errno == EINTR)
            {
                printf("read is interrupted by signal\n");
            }
        }
        else
        {
            buf[n] = '\0';
            printf("%d bytes read: %s\n", n, buf);
        }
    }
    return 0;
}
```

在这个例子中使用 sigaction 函数为 SIGUSR1 和 SIGUSR2 信号注册了处理函数，然后从标准输入读入字符。程序运行后首先输出自己的 PID，如：

```bash
My PID is 5904
```

这时如果从另外一个终端向进程发送 SIGUSR1 或 SIGUSR2 信号，用类似如下的命令：
kill -USR1 5904

则程序将继续输出如下内容：

```bash
SIGUSR1 received
read is interrupted by signal
```

这说明用 sigaction 注册信号处理函数时，不会自动重新发起被信号打断的系统调用。如果需要自动重新发起，则要设置 SA_RESTART 标志，比如在上述代码中可以进行类似一下的设置：

```c
sa_usr.sa_flags = SA_RESTART;
```

此外，这里的errno非常让人纠结，她到底是read函数的错误代码还是sigaction的错误代码？？

可以在 /usr/include/asm/errno.h 中找到errno的定义。







# System V 信号量（Sem）

## 定义

为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需要独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。

信号量是一个特殊的变量，程序对其访问都是原子操作，且只允许对它进行等待（即P(信号变量))和发送（即V(信号变量))信息操作。最简单的信号量是只能取0和1的变量，这也是信号量最常见的一种形式，叫做二进制信号量。而可以取多个正整数的信号量被称为通用信号量。这里主要讨论二进制信号量。



信号量（semaphore）是一种提供不同进程间或者一个给定进程不同线程之间的同步。 分为POSIX信号量和SystemV信号量，这里学习System V信号量。

信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。

信号量本质上是一个计数器（不设置全局变量是因为进程间是相互独立的，而这不一定能看到，看到也不能保证++引用计数为原子操作）,用于多进程对共享数据对象的读取，它和管道有所不同，它不以传送数据为主要目的，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。



## 工作原理

由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv),他们的行为是这样的：

（1）P(sv)：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行

（2）V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1.

在信号量进行PV操作时都为原子操作（因为它需要保护临界资源）

举个例子，就是两个进程共享信号量sv，一旦其中一个进程执行了P(sv)操作，它将得到信号量，并可以进入临界区，使sv减1。而第二个进程将被阻止进入临界区，因为当它试图执行P(sv)时，sv为0，它会被挂起以等待第一个进程离开临界区域并执行V(sv)释放信号量，这时第二个进程就可以恢复执行。

注：原子操作：单指令的操作称为原子的，单条指令的执行是不会被打断的。



##   二元信号量

二元信号量（Binary Semaphore）是最简单的一种锁（互斥锁），它只用两种状态：占用与非占用。所以它的引用计数为1。

##   进程如何获得共享资源

（1）测试控制该资源的信号量

（2）信号量的值为正，进程获得该资源的使用权，进程将信号量减1，表示它使用了一个资源单位

（3）若此时信号量的值为0，则进程进入挂起状态（进程状态改变），直到信号量的值大于0，若进程被唤醒则返回至第一步。

注：信号量通过同步与互斥保证访问资源的一致性。



## 与信号量相关的函数

### 所有函数共用头文件

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>　
```





### 创建信号量

```c
int semget(key_t key,int num_sems,int flags)
//返回:成功返回信号集ID，出错返回-1
```

它的作用是创建一个新信号量或取得一个已有信号量。

第一个参数是key整数型，不相关的进程可以通过它访问一个信号量，它代表程序可能要使用的某个资源，程序对所有信号量的访问都是间接的，先通过调用semget函数并提供一个键，再由系统生成一个相应的信号标识符（semget函数的返回值），只有semget函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。如果多个程序使用相同的key值，key将负责协调工作。

第二个参数num_sems指定需要的信号量数目，它的值几乎总是1。

第三个参数flags是一组标志位，当想要当信号量不存在时创建一个新的信号量，可以和值IPC_CREAT做按位或操作。设置了IPC_CREAT标志后，即使给出的键是一个已有信号量的键，也不会产生错误。而IPC_CREAT | IPC_EXCL则可以创建一个新的，唯一的信号量，如果信号量已存在，返回一个错误。

semget函数成功返回一个相应信号标识符（非零），失败返回-1。



### 改变信号量的值

```c
int semop(int semid, struct sembuf *sops, unsigned nsops);

struct sembuf{ 
    short sem_num;   //除非使用一组信号量，否则它为0 
    short sem_op;   //信号量在一次操作中需要改变的数据,通常是两个数，一个是-1，即P（等待）操作，一个是+1，即V（发送信号）操作。 
    short sem_flg; //通常为SEM_UNDO,使操作系统跟踪信号量， 并在进程没有释放该信号量而终止时，操作系统释放信号量 
}; 
```

semid是setget返回的信号量标识符。

sops是一个指针，它指向这样一个数组：元素用来描述对semid代表的信号量集合中第几个信号进行怎么样的操作。

+ sem_num是信号量的编号，除非使用一组信号量，否则它为0 
+ sem_op信号量在一次操作中需要改变的数据，通常是两个数，  一个是-1，即P（等待）操作， 一个是+1，即V（发送信号）操作。 
+ sem_flag通常为SEM_UNDO,使操作系统跟踪信号量， 并在进程没有释放该信号量而终止时，操作系统释放信号量 .

nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。

semop函数返回0表示成功，返回-1表示失败。

### 直接控制信号量

```c
int semctl(int semid, int semnum, int cmd, …);
```

semget并不会初始化每个信号量的值，这个初始化必须通过SETVAL命令或SETALL命令调用semctl来完成。

+ sem_id是由semget返回的信号量标识符.

+ semnum当前信号量集的哪一个信号量，即信号量编号，当需要用到成组的信号量时，就需要用到这个参数，一般取值为0，表示这是第一个唯一一个信号量。

+ cmd是将要采取的动作，通常是下面两个值中的其中一个：

  + SETVAL：用来把信号量初始化为一个已知的值。这个值通过union semun中的val成员设置，其作用是在信号量第一次使用前对它进行设置。

  + IPC_RMID：用于删除一个已经无需继续使用的信号量标识符，删除的话就不需要缺省参数，只需要三个参数即可。

  + IPC_STAT 获取信号量集的属性 -->buf

  + IPC_SET 设置信号量集的属性  -->buf

  + IPC_RMID 删除信号量集--->buf

  + GETVAL 返回信号量集的值 -->val

  + GETALL 获取所有信号量的值 -->array

  + SETALL 设置所有信号量的初始值 -->array

    

+ 如果有第四个参数，它通常是一个union semum结构，定义如下：

```c
union semun{
    int val;
    struct semid_ds *buf;
    unsigned short *arry;
}
```





# POSIX  信号量（Semaphore）

[Linux学习——进程间通信之posix信号量的使用](https://blog.csdn.net/tonglin12138/article/details/93751861)

[Linux进程间通信之POSIX信号量](https://blog.csdn.net/fengxinlinux/article/details/76507140)

[linux进程间通信：POSIX信号量](https://blog.csdn.net/Z_Stand/article/details/102066654)







## 1.概述

信号量（semaphore）是一种提供不同进程间或者一个给定进程不同线程之间的同步。 分为POSIX信号量和SystemV信号量，这里学习POSIX信号量。

POSIX信号量又分为有名信号量和基于内存的信号量（无名信号量）。区别在于是否需要使用POSIX IPC名字来标识。

```bash
NOTE：Linux操作系统中，POSIX有名信号量创建在虚拟文件系统中 
一般挂载在/dev/shm，其名字以sem.somename的形式存在。
```



## 2.信号量操作

早在学操作系统那会，就直到信号量的PV操作，总结一下大概是这么回事：

P操作，也叫做等待（wait）一个信号量，该操作会测试信号量的值，如果其值小于或等于0，将把当前进程/线程投入睡眠，当该信号量变得大于0后就将它减1。
伪代码如下，这两步必须是原子操作。

```c
while(sem <=0);
	sem--;
```

V操作，挂出（post）一个信号量，该操作将信号量值加1
伪代码如下：

```c
sem++;
```

信号量初始化的值的大小一般用于表示可用资源的数（例如缓冲区大小，之后代码中体现）;如果初始化为1，则称之二值信号量，二值信号量的功能就有点像互斥锁了。

**不同的是**：互斥锁的加锁和解锁必须在同一线程执行，而信号量的挂出却不必由执行等待操作的线程执行。

## 3.POSIX信号量相关接口：

```c
sem_t *sem_open(const char *name, int oflag); //使用字符串创建一个信号量
sem_t *sem_open(const char *name, int oflag,
            mode_t mode, unsigned int value); //使用字符串创一个一个信号量，并初始化信号量的值
int sem_close(sem_t *sem);
int sem_post(sem_t *sem); //信号量的v操作 +1
int sem_wait(sem_t *sem); //信号量的p操作 -1
int sem_trywait(sem_t *sem); //信号量进行p操作，但是值已经为0，此时会立即返回错而非阻塞

//信号量进行p操作，如信号量的值为0，则阻塞abs_timeout结构体中的时间内还是无法执行p操作，则返回错误
int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); 
int sem_unlink(const char *name);//删除名称为name的信号量
int sem_getvalue(sem_t *sem, int *sval);//获取信号量sem所代表的value数值

```

**注意事项  **

- 以上编程接口包含头文件: `#include <semaphore.h>`
- 编译时需指定：`-lpthread`进行编译



1.sem_init()初始化无名信号量

```c
#include <semaphore.h>
int sem_init(sem_t *sem, int pshared, unsigned int value);

//pshared指定该信号量用于进程还是线程同步
//0-表示用于线程同步（所有线程可见）
//非0-表示用于进程同步（需要放在共享内存中）

```

2.sem_open()初始化有名信号量

```c
#include <fcntl.h>           /* For O_* constants */
#include <sys/stat.h>        /* For mode constants */
#include <semaphore.h>
sem_t *sem_open(const char *name, int oflag);
sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);
Link with -pthread.
//套路跟之前的消息队列类似
//oflag可以设置为O_CREAT | O_EXCL (如果存在则返回错误)。
//mode可以设置为0644 自己可读写，其他用户和组内用户可读
//value表示信号量初始化的值

```

3.sem_wait()和sem_post()等待和挂出函数

```c
#include <semaphore.h>
int sem_wait(sem_t *sem);//P操作
int sem_post(sem_t *sem);//V操作
Link with -pthread.

```

sem_trywait()函数是sem_wait()的一个非阻塞版本。

```c
#include<semaphore.h>

int sem_trywait(sem_t *sem);123
```

如果递减操作无法立即被执行，那么sem_trywait()就会失败并返回EAGAIN错误。



4.sem_timedwait()超时等待

```c
 int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
 //跟sem_wait()类似，不过，如果P操作不能立即执行，该函数将投入睡眠
 //并等待abs_timeout中指定的时间。
 //如果超时依旧无法执行P操作，则返回timeout错误

```

## 4.1 无名信号量的创建

```c
sem_t sem;
...  ...
sem_init(&sem, 0, 0) == -1);

```

## 4.2 有名信号量的使用

```c
//有名信号量要指定一个名字somename，打开成功后
//将以sem.somename的形式存在于/dev/shm/目录下。 
//书中用二值信号量做互斥同步，这里我直接用mutex。

#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <semaphore.h>
#include <time.h>
#include <assert.h>
#include <errno.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pthread.h>

#define MAXSIZE 10
void *produce(void *); 
void *consume(void *);

typedef void *(*handler_t)(void *);//线程函数指针

struct _shared 
{
    int buff[MAXSIZE];

    sem_t *nempty;
    sem_t *nstored;
};//共享缓冲
typedef struct _shared shared;
shared shared_;
pthread_mutex_t mutex;//互斥锁
int nitems;//生产和消费的数目

int main(int argc,char **argv)
{
    if (argc !=2)
    {
        printf("usage:namedsem <#items>\r\n");
        exit(-1);
    }
    nitems=atoi(argv[1]);
    const char *const SEM_NEMPTY = "nempty";//信号量的“名字”
    const char *const SEM_NSTORED = "nstored";//信号量的“名字”
    pthread_t tid_produce;//生产者线程 id
    pthread_t tid_consume;//消费者线程 id
    //初始化信号量和互斥锁
    pthread_mutex_init(&mutex, NULL); 
    shared_.nstored=sem_open(SEM_NSTORED,O_CREAT|O_EXCL,0644,0);
    shared_.nempty=sem_open(SEM_NEMPTY,O_CREAT|O_EXCL,0644,MAXSIZE);
    memset(shared_.buff,0x00,MAXSIZE);

    //线程创建
    handler_t handler=produce;
    pthread_setconcurrency(2);
    if((pthread_create(&tid_produce,NULL,handler,NULL))<0)
    {
        printf("pthread_create error\r\n");
        exit(-1);
    }
//    sleep(5);
    handler=consume;
    if((pthread_create(&tid_consume,NULL,handler,NULL))<0)
    {
        printf("pthread_create error\r\n");
        exit(-1);
    }

    //线程回收
    pthread_join(tid_produce,NULL);
    pthread_join(tid_consume,NULL);

    //信号量锁销毁
    sem_unlink(SEM_NEMPTY);
    sem_unlink(SEM_NSTORED);
    pthread_mutex_destroy(&mutex);
    exit(0);
}



void *produce(void *args)
{
    int i;
    for(i=0;i<nitems;i++)
    {
        sem_wait(shared_.nempty);
        pthread_mutex_lock(&mutex);
        shared_.buff[i%MAXSIZE]=i;
        printf("add an item\r\n");
        pthread_mutex_unlock(&mutex);
        sem_post(shared_.nstored);
    }
    return NULL;
}


void *consume(void *args)
{
    int i;
    for(i=0;i<nitems;i++)
    {
        sem_wait(shared_.nstored);
        pthread_mutex_lock(&mutex);
        printf("consume an item\r\n");
        if(shared_.buff[i%MAXSIZE]!=i)
            printf("buff[%d]=%d\r\n",i,shared_.buff[i%MAXSIZE]);
        pthread_mutex_unlock(&mutex);
        sem_post(shared_.nempty);
    }
    return NULL;
}


```





#  消息队列（Message queues）















#  共享内存（Share Memory）



在Linux系统中，每个进程都有独立的虚拟内存空间，也就是说不同的进程访问同一段虚拟内存地址所得到的数据是不一样的，这是因为不同进程相同的虚拟内存地址会映射到不同的物理内存地址上。

但有时候为了让不同进程之间进行通信，需要让不同进程共享相同的物理内存，Linux通过 `共享内存` 来实现这个功能。下面先来介绍一下Linux系统的共享内存的使用。

## 共享内存使用

### 1. 获取共享内存

要使用共享内存，首先需要使用 `shmget()` 函数获取共享内存，`shmget()` 函数的原型如下：

```
int shmget(key_t key, size_t size, int shmflg);
```

- 参数 `key` 一般由 `ftok()` 函数生成，用于标识系统的唯一IPC资源。
- 参数 `size` 指定创建的共享内存大小。
- 参数 `shmflg` 指定 `shmget()` 函数的动作，比如传入 `IPC_CREAT` 表示要创建新的共享内存。

函数调用成功时返回一个新建或已经存在的的共享内存标识符，取决于shmflg的参数。失败返回-1，并设置错误码。

### 2. 关联共享内存

`shmget()` 函数返回的是一个标识符，而不是可用的内存地址，所以还需要调用 `shmat()` 函数把共享内存关联到某个虚拟内存地址上。`shmat()` 函数的原型如下：

```
void *shmat(int shmid, const void *shmaddr, int shmflg);
```

- 参数 `shmid` 是 `shmget()` 函数返回的标识符。
- 参数 `shmaddr` 是要关联的虚拟内存地址，如果传入0，表示由系统自动选择合适的虚拟内存地址。
- 参数 `shmflg` 若指定了 `SHM_RDONLY` 位，则以只读方式连接此段，否则以读写方式连接此段。

函数调用成功返回一个可用的指针（虚拟内存地址），出错返回-1。

### 3. 取消关联共享内存

当一个进程不需要共享内存的时候，就需要取消共享内存与虚拟内存地址的关联。取消关联共享内存通过 `shmdt()` 函数实现，原型如下：

```
int shmdt(const void *shmaddr);
```

- 参数 `shmaddr` 是要取消关联的虚拟内存地址，也就是 `shmat()` 函数返回的值。

函数调用成功返回0，出错返回-1。

### 共享内存使用例子

下面通过一个例子来介绍一下共享内存的使用方法。在这个例子中，有两个进程，分别为 `进程A` 和 `进程B`，`进程A` 创建一块共享内存，然后写入数据，`进程B` 获取这块共享内存并且读取其内容。



## 共享内存实现原理

我们先通过一幅图来了解一下共享内存的大概原理，如下图：![图片](https://mmbiz.qpic.cn/mmbiz_png/ciab8jTiab9J5YNGRcARP5poMfZhTZCOhoyn9SDc3TW2yFCC7sK5r4VmEvyvichLeJbMjk8MP5Ug3VJE2bDwQEuPA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

通过上图可知，共享内存是通过将不同进程的虚拟内存地址映射到相同的物理内存地址来实现的，下面将会介绍Linux的实现方式。

在Linux内核中，每个共享内存都由一个名为 `struct shmid_kernel` 的结构体来管理，而且Linux限制了系统最大能创建的共享内存为128个。通过类型为 `struct shmid_kernel` 结构的数组来管理，如下：

```c
struct shmid_ds {
 struct ipc_perm  shm_perm; /* operation perms */
 int   shm_segsz; /* size of segment (bytes) */
 __kernel_time_t  shm_atime; /* last attach time */
 __kernel_time_t  shm_dtime; /* last detach time */
 __kernel_time_t  shm_ctime; /* last change time */
 __kernel_ipc_pid_t shm_cpid; /* pid of creator */
 __kernel_ipc_pid_t shm_lpid; /* pid of last operator */
 unsigned short  shm_nattch; /* no. of current attaches */
 unsigned short   shm_unused; /* compatibility */
 void    *shm_unused2; /* ditto - used by DIPC */
 void   *shm_unused3; /* unused */
};

struct shmid_kernel
{ 
 struct shmid_ds  u;
 /* the following are private */
 unsigned long  shm_npages; /* size of segment (pages) */
 pte_t   *shm_pages; /* array of ptrs to frames -> SHMMAX */ 
 struct vm_area_struct *attaches; /* descriptors for attaches */
};

static struct shmid_kernel *shm_segs[SHMMNI]; // SHMMNI等于128
```

从注释可以知道 `struct shmid_kernel` 结构体各个字段的作用，比如 `shm_npages` 字段表示共享内存使用了多少个内存页。而 `shm_pages` 字段指向了共享内存映射的虚拟内存页表项数组等。

另外 `struct shmid_ds` 结构体用于管理共享内存的信息，而 `shm_segs数组` 用于管理系统中所有的共享内存。

### shmget() 函数实现

通过前面的例子可知，要使用共享内存，首先需要调用 `shmget()` 函数来创建或者获取一块共享内存。`shmget()` 函数的实现如下：

```c
asmlinkage long sys_shmget (key_t key, int size, int shmflg)
{
 struct shmid_kernel *shp;
 int err, id = 0;

 down(&current->mm->mmap_sem);
 spin_lock(&shm_lock);
 if (size < 0 || size > shmmax) {
  err = -EINVAL;
 } else if (key == IPC_PRIVATE) {
  err = newseg(key, shmflg, size);
 } else if ((id = findkey (key)) == -1) {
  if (!(shmflg & IPC_CREAT))
   err = -ENOENT;
  else
   err = newseg(key, shmflg, size);
 } else if ((shmflg & IPC_CREAT) && (shmflg & IPC_EXCL)) {
  err = -EEXIST;
 } else {
  shp = shm_segs[id];
  if (shp->u.shm_perm.mode & SHM_DEST)
   err = -EIDRM;
  else if (size > shp->u.shm_segsz)
   err = -EINVAL;
  else if (ipcperms (&shp->u.shm_perm, shmflg))
   err = -EACCES;
  else
   err = (int) shp->u.shm_perm.seq * SHMMNI + id;
 }
 spin_unlock(&shm_lock);
 up(&current->mm->mmap_sem);
 return err;
}
```

`shmget()` 函数的实现比较简单，首先调用 `findkey()` 函数查找值为key的共享内存是否已经被创建，`findkey()` 函数返回共享内存在 `shm_segs数组` 的索引。如果找到，那么直接返回共享内存的标识符即可。否则就调用 `newseg()` 函数创建新的共享内存。`newseg()` 函数的实现也比较简单，就是创建一个新的 `struct shmid_kernel` 结构体，然后设置其各个字段的值，并且保存到 `shm_segs数组` 中。

### shmat() 函数实现

`shmat()` 函数用于将共享内存映射到本地虚拟内存地址，由于 `shmat()` 函数的实现比较复杂，所以我们分段来分析这个函数：

```c
asmlinkage long sys_shmat (int shmid, char *shmaddr, int shmflg, ulong *raddr)
{
 struct shmid_kernel *shp;
 struct vm_area_struct *shmd;
 int err = -EINVAL;
 unsigned int id;
 unsigned long addr;
 unsigned long len;

 down(&current->mm->mmap_sem);
 spin_lock(&shm_lock);
 if (shmid < 0)
  goto out;

 shp = shm_segs[id = (unsigned int) shmid % SHMMNI];
 if (shp == IPC_UNUSED || shp == IPC_NOID)
  goto out;
```

上面这段代码主要通过 `shmid` 标识符来找到共享内存描述符，上面说过系统中所有的共享内存到保存在 `shm_segs` 数组中。

```c
 if (!(addr = (ulong) shmaddr)) {
  if (shmflg & SHM_REMAP)
   goto out;
  err = -ENOMEM;
  addr = 0;
 again:
  if (!(addr = get_unmapped_area(addr, shp->u.shm_segsz))) // 获取一个空闲的虚拟内存空间
   goto out;
  if(addr & (SHMLBA - 1)) {
   addr = (addr + (SHMLBA - 1)) & ~(SHMLBA - 1);
   goto again;
  }
 } else if (addr & (SHMLBA-1)) {
  if (shmflg & SHM_RND)
   addr &= ~(SHMLBA-1);       /* round down */
  else
   goto out;
 }
```

上面的代码主要找到一个可用的虚拟内存地址，如果在调用 `shmat()` 函数时没有指定了虚拟内存地址，那么就通过 `get_unmapped_area()` 函数来获取一个可用的虚拟内存地址。

```c
 spin_unlock(&shm_lock);
 err = -ENOMEM;
 shmd = kmem_cache_alloc(vm_area_cachep, SLAB_KERNEL);
 spin_lock(&shm_lock);
 if (!shmd)
  goto out;
 if ((shp != shm_segs[id]) || (shp->u.shm_perm.seq != (unsigned int) shmid / SHMMNI)) {
  kmem_cache_free(vm_area_cachep, shmd);
  err = -EIDRM;
  goto out;
 }
```

上面的代码主要通过调用 `kmem_cache_alloc()` 函数创建一个 `vm_area_struct` 结构，在内存管理一章知道，`vm_area_struct` 结构用于管理进程的虚拟内存空间。

```c
 shmd->vm_private_data = shm_segs + id;
 shmd->vm_start = addr;
 shmd->vm_end = addr + shp->shm_npages * PAGE_SIZE;
 shmd->vm_mm = current->mm;
 shmd->vm_page_prot = (shmflg & SHM_RDONLY) ? PAGE_READONLY : PAGE_SHARED;
 shmd->vm_flags = VM_SHM | VM_MAYSHARE | VM_SHARED
    | VM_MAYREAD | VM_MAYEXEC | VM_READ | VM_EXEC
    | ((shmflg & SHM_RDONLY) ? 0 : VM_MAYWRITE | VM_WRITE);
 shmd->vm_file = NULL;
 shmd->vm_offset = 0;
 shmd->vm_ops = &shm_vm_ops;

 shp->u.shm_nattch++;     /* prevent destruction */
 spin_unlock(&shm_lock);
 err = shm_map(shmd);
 spin_lock(&shm_lock);
 if (err)
  goto failed_shm_map;

 insert_attach(shp,shmd);  /* insert shmd into shp->attaches */

 shp->u.shm_lpid = current->pid;
 shp->u.shm_atime = CURRENT_TIME;

 *raddr = addr;
 err = 0;
out:
 spin_unlock(&shm_lock);
 up(&current->mm->mmap_sem);
 return err;
 ...
}
```

上面的代码主要是设置刚创建的 `vm_area_struct` 结构的各个字段，比较重要的是设置其 `vm_ops` 字段为 `shm_vm_ops`，`shm_vm_ops` 定义如下：

```c
static struct vm_operations_struct shm_vm_ops = {
 shm_open,  /* open - callback for a new vm-area open */
 shm_close,  /* close - callback for when the vm-area is released */
 NULL,   /* no need to sync pages at unmap */
 NULL,   /* protect */
 NULL,   /* sync */
 NULL,   /* advise */
 shm_nopage,  /* nopage */
 NULL,   /* wppage */
 shm_swapout  /* swapout */
};
```

`shm_vm_ops` 的 `nopage` 回调为 `shm_nopage()` 函数，也就是说，当发生页缺失异常时将会调用此函数来恢复内存的映射。

从上面的代码可看出，`shmat()` 函数只是申请了进程的虚拟内存空间，而共享内存的物理空间并没有申请，那么在什么时候申请物理内存呢？答案就是当进程发生缺页异常的时候会调用 `shm_nopage()` 函数来恢复进程的虚拟内存地址到物理内存地址的映射。

### shm_nopage() 函数实现

shm_nopage() 函数是当发生内存缺页异常时被调用的，代码如下：

```c
static struct page * shm_nopage(struct vm_area_struct * shmd, unsigned long address, int no_share)
{
 pte_t pte;
 struct shmid_kernel *shp;
 unsigned int idx;
 struct page * page;

 shp = *(struct shmid_kernel **) shmd->vm_private_data;
 idx = (address - shmd->vm_start + shmd->vm_offset) >> PAGE_SHIFT;

 spin_lock(&shm_lock);
again:
 pte = shp->shm_pages[idx]; // 共享内存的页表项
 if (!pte_present(pte)) {   // 如果内存页不存在
  if (pte_none(pte)) {
   spin_unlock(&shm_lock);
   page = get_free_highpage(GFP_HIGHUSER); // 申请一个新的物理内存页
   if (!page)
    goto oom;
   clear_highpage(page);
   spin_lock(&shm_lock);
   if (pte_val(pte) != pte_val(shp->shm_pages[idx]))
    goto changed;
  } else {
   ...
  }
  shm_rss++;
  pte = pte_mkdirty(mk_pte(page, PAGE_SHARED));   // 创建页表项
  shp->shm_pages[idx] = pte;                      // 保存共享内存的页表项
 } else
  --current->maj_flt;  /* was incremented in do_no_page */

done:
 get_page(pte_page(pte));
 spin_unlock(&shm_lock);
 current->min_flt++;
 return pte_page(pte);
 ...
}
```

shm_nopage() 函数的主要功能是当发生内存缺页时，申请新的物理内存页，并映射到共享内存中。由于使用共享内存时会映射到相同的物理内存页上，从而不同进程可以共用此块内存。





#  内存映射（Memory Map）

假设采用标准系统调用 open()、read() 和 write() 来顺序读取磁盘文件，每个文件访问都需要系统调用和磁盘访问。又或者采用虚拟内存技术，以将文件 I/O 作为常规内存访问，这种方法称为内存映射文件，允许一部分虚拟内存与文件进行逻辑关联，这会导致显著的性能提高。

## 基本机制

实现文件的内存映射是将每个磁盘块映射到一个或多个内存页面。

最初，文件访问按普通请求调页来进行，从而产生缺页错误。这样，文件的页面大小部分从文件系统读取到物理页面（有些系统可以选择一次读取多个页面大小的数据块）。以后，文件的读写就按常规内存访问来处理。通过内存的文件操作，没有采用系统调用 read() 和 write() 的开销，而且简化了文件的访问和使用。

请注意，内存映射文件的写入不一定是对磁盘文件的即时（同步）写入。有的操作系统定期检查文件的内存映射页面是否已被修改，以便选择是否更新到物理文件。当关闭文件时，所有内存映射的数据会写到磁盘，并从进程虚拟内存中删除。

有些操作系统仅通过特定的系统调用来提供内存映射，而通过标准的系统调用来处理所有其他文件 I/O。然而，有的系统不管文件是否指定为内存映射，都选择对文件进行内存映射。

以 Solaris 为例，如果一个文件指定为内存映射（采用系统调用 mmaP()），那么 Solaris 会将该文件映射到进程地址空间。如果一个文件通过普通系统调用，如 open()、read() 和 write() 来打开和访问，那么 Solaris 仍然采用内存映射文件。然而，这个文件是映射到内核地址空间，无论文件如何打开，Solaris 都将所有文件 I/O 视为内存映射的，以允许文件访问在高效的内存子系统中进行。

多个进程可以允许并发地内存映射同一文件，以便允许数据共享。任何一个进程的写入会修改虚拟内存的数据，并且其他映射同一文件部分的进程都可看到。

根据虚拟内存的相关知识，可以清楚地看到内存映射部分的共享是如何实现的：每个共享进程的虚拟内存映射指向物理内存的同一页面，而该页面有磁盘块的复制，这种内存共享如图 1 所示。


![内存映射文件](http://c.biancheng.net/uploads/allimg/181109/2-1Q109100J11H.gif)

​																															 图 1 内存映射文件


内存映射系统调用还可以支持写时复制功能，允许进程既可以按只读模式来共享文件，也可以拥有自己修改的任何数据的副本。为了协调对共享数据的访问，有关进程可以使用实现互斥的机制。

很多时候，共享内存实际上是通过内存映射来实现的。在这种情况下，进程可以通过共享内存来通信，而共享内存是通过映射同样文件到通信进程的虚拟地址空间来实现的。内存映射文件充当通信进程之间的共享内存区域（图 2）。


![采用内存映射I/O的共享内存](http://c.biancheng.net/uploads/allimg/181109/2-1Q109100Q3932.gif)

​																														图 2 采用内存映射 I/O 的共享内存


首先创建 POSIX 共享内存对象，然后每个通信进程内存对象映射到其地址空间。在接下来的部分，将说明 Windows API 如何支持通过内存映射文件的内存共享。





头文件：#include <unistd.h>   #include <sys/mman.h>

定义函数：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offsize);

函数说明：mmap()用来将某个文件内容映射到内存中，对该内存区域的存取即是直接对该文件内容的读写。

参数说明：

| 参数   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| start  | 指向欲对应的内存起始地址，通常设为NULL，代表让系统自动选定地址，对应成功后该地址会返回。 |
| length | 代表将文件中多大的部分对应到内存。                           |
| prot   | 代表映射区域的保护方式，有下列组合：PROT_EXEC  映射区域可被执行；PROT_READ  映射区域可被读取；PROT_WRITE  映射区域可被写入；PROT_NONE  映射区域不能存取。 |
| flags  | 会影响映射区域的各种特性：MAP_FIXED  如果参数 start 所指的地址无法成功建立映射时，则放弃映射，不对地址做修正。通常不鼓励用此旗标。MAP_SHARED  对应射区域的写入数据会复制回文件内，而且允许其他映射该文件的进程共享。MAP_PRIVATE  对应射区域的写入操作会产生一个映射文件的复制，即私人的"写入时复制" (copy on write)对此区域作的任何修改都不会写回原来的文件内容。MAP_ANONYMOUS  建立匿名映射，此时会忽略参数fd，不涉及文件，而且映射区域无法和其他进程共享。MAP_DENYWRITE  只允许对应射区域的写入操作，其他对文件直接写入的操作将会被拒绝。MAP_LOCKED  将映射区域锁定住，这表示该区域不会被置换(swap)。 在调用mmap()时必须要指定MAP_SHARED 或MAP_PRIVATE。 |
| fd     | open()返回的文件描述词，代表欲映射到内存的文件。             |
| offset | 文件映射的偏移量，通常设置为0，代表从文件最前方开始对应，offset必须是分页大小的整数倍。 |


返回值：若映射成功则返回映射区的内存起始地址，否则返回MAP_FAILED(-1)，错误原因存于errno 中。

错误代码：

- EBADF  参数fd 不是有效的文件描述词。

- EACCES  存取权限有误。如果是MAP_PRIVATE 情况下文件必须可读，使用MAP_SHARED 则要有PROT_WRITE 以及该文件要能写入。

- EINVAL  参数start、length 或offset 有一个不合法。

- EAGAIN  文件被锁住，或是有太多内存被锁住。

- ENOMEM  内存不足。

  

**C语言munmap()函数：解除内存映射**

头文件：

\#include <unistd.h>    

\#include <sys/mman.h>

定义函数：int munmap(void *start, size_t length);

函数说明：munmap()用来取消参数start 所指的**映射内存起始地址**，参数length 则是欲取消的**内存大小**。

当进程结束或利用exec 相关函数来执行其他程序时，映射内存会自动解除，但关闭对应的文件描述词时不会解除映射。

返回值：如果解除映射成功则返回0，否则返回－1。错误原因存于errno 中错误代码EINVAL参数 start 或length 不合法。

范例：利用mmap()来读取/etc/passwd 文件内容。

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/mman.h>

main(){    
int fd;    
void *start;    
struct stat sb;    
fd = open("/etc/passwd", O_RDONLY); /*打开/etc/passwd */    
fstat(fd, &sb); /* 取得文件大小 */    
start = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);    
if(start == MAP_FAILED) /* 判断是否映射成功 */        
return;    
printf("%s", start); 
munma(start, sb.st_size); /* 解除映射 */    
closed(fd);
}
```

执行结果：

```c
root : x : 0 : root : /root : /bin/bash
bin : x : 1 : 1 : bin : /bin :
daemon : x : 2 : 2 :daemon : /sbin
adm : x : 3 : 4 : adm : /var/adm :
lp : x :4 :7 : lp : /var/spool/lpd :
sync : x : 5 : 0 : sync : /sbin : bin/sync :
shutdown : x : 6 : 0 : shutdown : /sbin : /sbin/shutdown
halt : x : 7 : 0 : halt : /sbin : /sbin/halt
mail : x : 8 : 12 : mail : /var/spool/mail :
news : x :9 :13 : news : /var/spool/news :
uucp : x :10 :14 : uucp : /var/spool/uucp :
operator : x : 11 : 0 :operator : /root:
games : x : 12 :100 : games :/usr/games:
gopher : x : 13 : 30 : gopher : /usr/lib/gopher-data:
ftp : x : 14 : 50 : FTP User : /home/ftp:
nobody : x :99: 99: Nobody : /:
xfs :x :100 :101 : X Font Server : /etc/xll/fs : /bin/false
gdm : x : 42 :42 : : /home/gdm: /bin/bash
kids : x : 500 :500 :/home/kids : /bin/bash
```







# 套接字 

 



##  Socket函数介绍与使用

[<font color=green> <工程师纯干货总结：TCP/IP 网络编程></font>](https://mp.weixin.qq.com/s/SIFdmkoZDVJGD-0Z4SIEiA)

[<font color=green><linux C socket 函数介绍和使用实例></font>](https://blog.csdn.net/XiaoXiaoPengBo/article/details/50349834)



以上两篇文章是以下内容的铺垫。

Socket 是应用层与协议族通信的中间软件抽象层，它是一组接口。

先附图一张，虽然是讲解 TCP 的 socket，但是道理相通。

![img](https://img-blog.csdn.net/20151218101102971?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

### 基本 socket 函数

Linux 系统是通过提供套接字 (socket) 来进行网络编程的。网络的 socket 数据传输是一种特殊的I/O,socket 也是一种文件描述符。socket 也有一个类似于打开文件的函数：socket (), 调用 socket (), 该函数返回一个整型的 socket 的描述符，随后的连接建立、数据传输等操作也都是通过该 socket 实现。

####   socket 函数

```c
#include <sys/scoket.h>
int socket(int af, int type, int protocol)；
```

<font color=blue> 功能说明：</font>

+ 调用成功，返回 socket 文件描述符；失败，返回－ 1，并设置errno;两个网络程序之间的一个网络连接包括五种信息：通信协议、本地协议地址、本地主机端口、远端主机地址和远端协议端口。 socket 数据结构中包含这五种信息。

<font color=blue> 参数说明：</font>

+ af 指明所使用的协议族，通常为 PF_INET，表示 TCP/IP协议。AF 是“Address Family”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。大家需要记住 127.0.0.1，它是一个特殊 IP 地址，表示本机地址，后面的教程会经常用到;

  | 名称     | 协议族               |
  | -------- | -------------------- |
  | PF_INET  | IPv4 互联网协议族    |
  | PF_INET6 | IPv4 互联网协议族    |
  | PF_LOCAL | 本地通信 unix 协议族 |


   + type 参数指定 socket 的类型，基本上有三种：数据流套接字、数据报套接字、原始套接字;

     + 面向链接的套接字类型 (SOCK_STREAM)

        SOCK_STREAM 表示面向连接的数据传输方式。数据可以准确无误地到达另一台计算机，如果损坏或丢失，可以重新发送，但效率相对较慢。常见的 http 协议就使用SOCK_STREAM 传输数据，因为要确保数据的正确性，否则网页不能正常解析。

     + 面向消息的套接字类型 ( SOCK_DGRAM)

        SOCK_DGRAM 表示无连接的数据传输方式。计算机只管传输数据，不作数据校验，如果数据在传输中损坏，或者没有到达另一台计算机，是没有办法补救的。也就是说，数据错了就错了，无法重传。因为 SOCK_DGRAM 所做的校验工作少，所以效率比 SOCK_STREAM 高。

     <font color=red>注意：SOCK_DGRAM 没有想象中的糟糕，不会频繁的丢失数据，数据错误只是小概率事件。</font>



   + protocol : 计算机通信中实用的协议信息， protocol 参数协议最终选择,常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP传输协议和 UDP 传输协议。
     有了地址类型和数据传输方式，还不足以决定采用哪种协议吗？为什么还需要第三个参数呢？正如大家所想，一般情况下有了 af 和 type 两个参数就可以创建套接字了，操作系统会自动推演出协议类型，除非遇到这样的情况：有两种不同的协议支持同一种地址类型和数据传输类型。如果我们不指明使用哪种协议，操作系统是没办法自动推演的。该教程使用 IPv4 地址，参数 af 的值为 PF_INET。如果使用
     SOCK_STREAM 传输数据，那么满足这两个条件的协议只有TCP，因此可以这样来调用 socket () 函数;

     ```c
     int tcp_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); // IPPROTO_TCP表示TCP协议
     ```

     这种套接字称为 TCP 套接字。

     如果使用 SOCK_DGRAM 传输方式，那么满足这两个条件的协议只有 UDP，因此可以这样来调用 socket () 函数：

     ```c
     int ud_socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); //IPPROTO_UDP表示UDP协议
     ```

     这种套接字称为 UDP 套接字。
     上面两种情况都只有一种协议满足条件，可以将 protocol 的值设为 0，系统会自动推演出应该使用什么协议，如下所示：

     ```c
     int tcp_socket = socket(AF_INET, SOCK_STREAM, 0); //创建TCP套接字
     int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); //创建UDP套接字
     ```



####   bind 函数

```c
#include <sys/socket.h>
int bind(int server_sockfd, struct sockaddr *server_addr, int addrlen);
// socketfd 要分配的套接字文件描述 符
// myaddr 存储地址信息的结构体变量地址值
// addrlen 第二个结构体变量的长度
```

<font color=blue>功能说明：</font>

+ 调将套接字和指定的端口相连，对于服务器和客户端都是这样。成功返回 0，否则，返回-1，并置 errno;

<font color=blue>参数说明：</font>

+ server_sockfd 是调用 socket 函数返回值;

+ server_addr 是一个指向包含有本机 IP 地址及端口号等信息的sockaddr类型的指针；

  ```c
  struct sockaddr {
      __uint8_t sa_len;
      sa_family_t sa_family; //地址族
      char sa_data[14]; //地址信息
  };
  ```

  在 sa_data 一个成员里，包含了 ip、port 的地址信息，这样写起来很麻烦，所以有了新的结构体 sockaddr_in (IP 和端口进行了拆分)。sockaddr_in 结构体：

  ```c
  typedef unsigned short int	uint16_t;
  typedef uint16_t in_port_t;
  typedef unsigned short int sa_family_t;
  
  struct sockaddr_in {
      __uint8_t sin_len;
      sa_family_t sin_family;  //地址族
      in_port_t sin_port;      // TCP/UDP端口号
      struct in_addr sin_addr; //IP地址
      char sin_zero[8];
  };
  
  //在上面的结构体中，又嵌套了 in_addr 结构体，记录 IP 地址:
  typedef unsigned int	uint32_t;
  typedef uint32_t   in_addr_t;
  struct in_addr{
      in_addr_t s_addr; //32位IPv4地址
  };
  
  ```





  <font color=blue>结构体 sockaddr_in 的成员分析:</font>

  +  **成员 sin_family**:

    | 地址族   | 含义                       |
    | :------- | :------------------------- |
    | AF_INET  | IPv4 互联网使用的地址族    |
    | AF_INET6 | IPv6 互联网使用的地址族    |
    | AF_LOCAL | 本地通信 unix 使用的地址族 |
    | …        | …                          |

  + **成员 sin_port**:16 位端口号;

  + **成员 sin_addr**:32 位 ip 地址信息，以网络字节序保存;

  + **成员 sin_zero**:无特殊含义，为与 sockaddr 大小保持一致，写入 0 即可。

+ **addrlen 参数**:传递地址信息的长度;

  <font color=blue>**最终我们使用 bind 绑定地址方式**</font>

```c
//分配内存-构造服务端地址端口
memset(&serv_addr, 0, sizeof(serv_addr));
//IPv4中的地址族
serv_addr.sin_family = AF_INET;
//32位的IPv4地址， INADDR_ANY表示当前ip
serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
//16位tcp/udp端口号
serv_addr.sin_port = htons(atoi(argv[1]));

//分配地址
if (bind(serv_sock, (struct sockaddr*) &serv_addr,sizeof(serv_addr) )==-1){
    printf("bind() error");
    exit(0);
}
```

   bind 函数之前，构造了 sockaddr_in 结构体的数据，其中介绍几个点.

 + INADDR_ANY 会自动获取当前服务器的 IP;

 + 我们看到使用到了 htonl、htons 函数，构造 IP 地址和端口;

**==为什么构造结构体地址时候使用了 htonl、htons 对 IP、端口进行了转换？==**

首先我们来看下这几个函数的含义:

| 地址族 | 含义                                        |
| :----- | :------------------------------------------ |
| htons  | 把 short 型数据从主机字节序转化为网络字节序 |
| htonl  | 把 long 型数据从主机字节序转化为网络字节序  |
| ntohs  | 把 short 型数据从网络字节序转化为主机字节序 |
| ntohl  | 把 long 型数据从网络字节序转化为主机字节序  |
| …      | …                                           |

数据传输采用的网络字节序，那在传输前应直接把数据转换成网络字节序，接收的数据也需要转换城主机字节序再保存。上面这句话是有问题的，原因是数据收发过程中是有自动转换机制的。

除了 socketaddr_in 结构体变量手动填充数据转换外，其他情况不需要考虑字节序问题。

**==说了这么多字节序，那到底什么是网络字节序，什么是主机字节序==**

- 主机字节序：主机内部内存中数据的处理方式。
- 网络字节序：网络字节顺序是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用 big endian（大端）排序方式。

 **==大端又是啥，我们从两种网络字节顺序说起==**

+ 字节序：是指整数在内存中保存的顺序
+ cpu 向内存保存数据字节序有两种实现方式：
  + **小端字节序（little endian）**：低字节数据存放在内存低地址处，高字节数据存放在内存高地址处。
  + **大端字节序（bigendian）**：高字节数据存放在低地址处，低字节数据存放在高地址处。

图例:

![图片](https://mmbiz.qpic.cn/mmbiz_png/ABBvyuGJ3WYYGdFRRtMFt3qoXUaYUe9YH9XnibbNYb65sXubofOP3NrtY3up9fhtUIWGIPEtXwcRchvUYdszBzQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ABBvyuGJ3WYYGdFRRtMFt3qoXUaYUe9YbSdemjnWVQiaT7eXbo2NKR5oeIQdrOydHiclWAIicuD1Bn54AK9zIdHlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)



大字节序更符合我们的阅读习惯。但是我们的主机使用的是哪种字节序取决于 CPU，不同的 CPU 型号有不同的选择。

当我们两台计算机是需要网络通信时，规范统一约定为大端序进行通讯处理.



#### htonl/htons/ntohl/ntohs函数



htonl 函数将主机的 unsigned long 值转换成网络字节顺序（32 位）（一般主机跟网络上传输的字节顺序是不通的，分大小端），函数返回一个网络字节顺序的数字。

作用相反的函数即把网络字节顺序转化成主机序列为 ntohl () 函数。

记忆这类函数，主要看前面的 n 和后面的 hl。。n 代表网络，h 代表主机 host，l 代表 long 的长度，还有相对应的 s 代表 16 位的 short

> 同类的函数：ntohs ()、htons () 就是转成 short 类型的。

```c
//
main(){
//u_long a = 0x12345678;
//u_long b = htonl (a);// 将主机的 unsigned long 转为网络字节顺序（32 位）
//u_long b = ntohl (a);// 将网络字节顺序（32 位）转为主机字节


u_short a = 0x1234;
//u_short b = ntohs (a);//32 位
u_short b = htons(a);
}
```



#### inet_addr / inet_ntoa函数

函数原型：

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

typedef unsigned int	uint32_t;
typedef uint32_t   in_addr_t;
typedef unsigned short int	uint16_t;
typedef uint16_t in_port_t;
typedef unsigned short int sa_family_t;


struct sockaddr_in {
    __uint8_t sin_len;
    sa_family_t sin_family;  //地址族
    in_port_t sin_port;      // TCP/UDP端口号
    struct in_addr sin_addr; //IP地址
    char sin_zero[8];
};


struct in_addr{
    in_addr_t s_addr; //32位IPv4地址
};

in_addr_t inet_addr(const char *cp);
int inet_aton(const char *cp, struct in_addr *inp);
char *inet_ntoa(struct in_addr in)
```

函数说明：inet_addr () 用来将参数 cp 所指的网络地址字符串转换成网络所使用的二进制数字。网络地址字符串是以数字和点组成的字符串，例如：`"163. 13. 132. 68"`。

返回值：成功则返回对应的网络二进制的数字，失败返回 - 1.

```c
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <stdlib.h>

int main()
{
    struct sockaddr_in m_sockaddr;
    m_sockaddr.sin_family = AF_INET;
    //将字符串转换为in_addr类型
    m_sockaddr.sin_addr.s_addr = inet_addr("192.168.1.111");
    m_sockaddr.sin_port = htons(5000);

    printf("#############  1  ##########################\n\n");
    printf("inet_addr(\"192.168.1.111\") = %u\n", inet_addr("192.168.1.111"));
    printf("m_sockaddr.sin_addr.s_addr = %u\n", inet_addr("192.168.1.111"));
    printf("inet_addr ip = %u\n", inet_addr("192.168.1.111"));

    //将s_addr类型转换为字符串
    printf("inet_ntoa ip = %s\n", inet_ntoa(m_sockaddr.sin_addr));

    m_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    m_sockaddr.sin_port = htons(5000);
    printf("#############  2  ##########################\n\n");
    printf("inet_addr(\"192.168.1.111\") = %u\n", htonl(INADDR_ANY));
    printf("m_sockaddr.sin_addr.s_addr = %u\n", htonl(INADDR_ANY));
    printf("inet_addr ip = %u\n", htonl(INADDR_ANY));

    //将s_addr类型转换为字符串
    printf("inet_ntoa ip = %s\n", inet_ntoa(m_sockaddr.sin_addr));

    return 0;
}

```

输出如下：

```bash
# junjie @ Ubuntu in ~/公共的/c文件/systemlib [日期: 周二 3月 16日, 时间:20:51:07]
$ ./test
#############  1  ##########################

inet_addr("192.168.1.111") = 1862379712
m_sockaddr.sin_addr.s_addr = 1862379712
inet_addr ip = 1862379712
inet_ntoa ip = 192.168.1.111
#############  2  ##########################

inet_addr("192.168.1.111") = 0
m_sockaddr.sin_addr.s_addr = 0
inet_addr ip = 0
inet_ntoa ip = 0.0.0.0
```





#### **inet_pton** /  **inet_ntop**函数

```c
#include <arpa/inet.h>
int inet_pton(int af, const char *src, void *dst);
```

 <font color=blue>功能说明：</font>

+ 将 IPv4 和 IPv6 地址从点分十进制转换为二进制

+ 该函数将字符串 `src` 转换为 `af` 地址类型协议簇的网络地址，并存储到 `dst` 中。对于 `af` 参数，必须为 `AF_INET` 或 `AF_INET6`

<font color=blue>返回值：</font>

+ `inet_pton` 转换成功则返回 1, 对于指定的地址类型协议簇，如果不是一个有效的网络地址，将转换失败，返回 0, 如果指定的地址类型协议簇不合法，将返回 - 1 并，并且 `errno` 设置为 `EAFNOSUPPORT `



```c
#include <arpa/inet.h>
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
```

 <font color=blue>功能说明：</font>

+ 将 IPv4 和 IPv6 地址从二进制转换为点分十进制

+ 该函数将地址类型协议簇为 `af` 的网络地址 `src` 转换为字符串，并将其存储到 `dst` 中，其中 `dst` 不能是空指针。调用者在参数 `size` 中指定可使用的缓冲字节数。

<font color=blue>返回值：</font>

+ `inet_ntop` 执行成功，返回一个指向 `dst` 的非空指针，如果执行失败，将返回 `NULL`，并且 `errno` 设置为相应的错误类型。

<font color=blue>错误代码：</font>

- EAFNOSUPPORT
  `af` 并不是一个合法的地址类型协议簇
- ENOSPC
  要转换的字符串地址 `src` 其字节大小超过了给定的缓冲字节大小



> 实例
>
> ```c
> #include <arpa/inet.h>
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> 
> int main(int argc, char *argv[])
> {
> unsigned char buf[sizeof(struct in6_addr)];
> int domain, s;
> char str[INET6_ADDRSTRLEN];
> 
> if (argc != 3)
> {
>   fprintf(stderr, "Usage: %s {i4|i6|<num>} string\n", argv[0]);
>   exit(EXIT_FAILURE);
> }
> 
> domain = (strcmp(argv[1], "i4") == 0) ? AF_INET : (strcmp(argv[1], "i6") == 0) ? AF_INET6: atoi(argv[1]);
> 
> s = inet_pton(domain, argv[2], buf);
> if (s <= 0)
> {
>   if (s == 0)
>       fprintf(stderr, "Not in presentation format");
>   else
>       perror("inet_pton");
>   exit(EXIT_FAILURE);
> }
> 
> if (inet_ntop(domain, buf, str, INET6_ADDRSTRLEN) == NULL)
> {
>   perror("inet_ntop");
>   exit(EXIT_FAILURE);
> }
> 
> printf("%s\n", str);
> 
> exit(EXIT_SUCCESS);
> }
> ```
>
> 输出：
>
> ```c
> # junjie @ Ubuntu in ~/公共的/c文件/systemlib [日期: 周二 3月 16日, 时间:21:05:51]
> $ ./test i4 192.168.1.110
> 192.168.1.110
> ```
>
> 



####   connect 函数

```c
#include <sys/types.h>
int connect(int client_sockfd, struct sockaddr_in *serv_addr,int addrlen);
```

<font color=blue>功能说明：</font>

+ 客户端发送服务请求，只有客户端才用，对于客户端，client_sockfd是客户端 socket() 返回的套接字描述符，serv_addr 是服务端的sockadd_in 结构体。成功返回 0，否则返回-1，并置 errno。

<font color=blue>参数说明：</font>

+ client_sockfd 是客户端 socket 函数返回的 socket 描述符；serv_addr是包含远端主机 IP 地址和端口号的指针；addrlen 是结构 sockaddr_in 的长度。

####  listen 函数

   ```c
   #include <sys/socket.h>
   int listen(int sock_fd, int backlog);  //Linux
   int listen(SOCKET sock, int backlog);  //Windows
   ```


<font color=blue>功能说明：</font>

   + 等待指定的端口的出现客户端连接，只有服务器端才用。调用

    成功返回 0，否则，返回－ 1，并置 errno.

<font color=blue>参数说明：</font>

   + sock_fd 是服务器端 socket() 函数返回值；
   + backlog 指定在请求队列中允许的最大请求数

   **请求队列**

   当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。

   缓冲区的长度（能存放多少个客户端请求）可以通过 listen () 函数的 backlog 参数指定，但究竟为多少并没有什么标准，可以根据你的需求来定，并发量小的话可以是 10 或者 20。

   如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。

   当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误，对于 Windows，客户端会收到 WSAECONNREFUSED 错误。

   <font color=red>注意：listen () 只是让套接字处于监听状态，并没有接收请求。接收请求需要使用 accept () 函数。</font>

> ##### accept函数

   ```c
   #include <sys/types.h>
   int accept(int server_sockfd, struct sockadd * client_addr, int addrlen);
   ```

   <font color=blue>功能说明：</font>

   + 只在服务端使用，用于接受客户端的服务请求，成功返回新的套接字描述符 clent_sockfd，这个新的描述符是服务端的 send/recv/read/write 函数的第一个参数，失败返回－1，并置 errno。

     errno错误代码：

     + EBADF 参数 s 非合法 socket 处理代码.
     + EFAULT 参数 addr 指针指向无法存取的内存空间.
     + ENOTSOCK 参数 s 为一文件描述词，非 socket.
     + EOPNOTSUPP 指定的 socket 并非 SOCK_STREAM.
     + EPERM 防火墙拒绝此连线.
     + ENOBUFS 系统的缓冲内存不足.
     + ENOMEM 核心内存不足.

   <font color=blue>参数说明：</font>

   + server_sockfd 是被监听的 socket 描述符，也就是服务端的 socket 返回的 socket 描述符，是服务器端套接字, addr 通常是一个指向客户端 sockaddr 变量的指针，这个指针的内容是不需要指定的，只需要定义、分配好内存空间；addrlen 是结构 sockaddr 的长度。

   <font color=red>注意：accept () 返回一个新的套接字来和客户端通信，client_addr 保存了客户端的 IP 地址和端口号，而 sock 是服务器端的套接字，大家注意区分。后面服务端和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。accept () 用来接受参数 server_sockfd 的 socket 连线。参数 server_sockfd 的 socket 必需先经 bind ()、listen () 函数处理过，当有连线进来时 accept () 会返回一个新的 socket 处理代码，往后的数据传送与读取就是经由新的 socket 处理，而原来参数 server_sockfd 的 socket 能继续使用 accept () 来接受新的连线要求。连线成功时，参数 client_addr 所指的结构会被系统填入远程主机的地址数据，参数 addrlen 为 scokaddr 的结构长度。

   最后需要说明的是：listen () 只是让套接字进入监听状态，并没有真正接收客户端请求，listen () 后面的代码会继续执行，直到遇到 accept ()。accept () 会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。</font>



####   write函数

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t nbytes);
```

<font color=blue>功能说明：</font>

+ write 函数将 buf 中的 nbytes 字节内容写入文件描述符 fd，write () 会把参数 buf 所指的内存写入 count 个字节到参数 fd 所指的文件内。当然，文件读写位置也会随之移动. 对于客户端，fd 为客户端 socket 返回的套接字描述符 client_sockfd，对于服务端，fd 为 accept 返回的新的套接字描述符。成功时返回写的字节数. 失败时返回-1. 并设置 errno 变量,错误代码：
  + EINTR 此调用被信号所中断.
  + EAGAIN 当使用不可阻断 I/O 时 (O_NONBLOCK), 若无数据可读取则返回此值.
  + EADF 参数 fd 非有效的文件描述词，或该文件已关闭.

<font color=blue>参数说明：</font>

####    read函数

```c
#include <unistd.h>
ssize_t read(int fd,void *buf,size_t nbyte);
```



<font color=blue>功能说明：</font>

+ read 函数是负责从 fd 中读取内容，对于客户端，fd 为客户端socket 返回的套接字描述符 client_sockfd，对于服务端，fd 为accept 返回的新的套接字描述符。当读成功时，read 返回实际
  所读的字节数，如果返回的值是 0 表示已经读到文件的结束了,当有错误发生时则返回-1, 错误代码存入 errno 中，而文件读写位置则无法预期. 小于 0 表示出现了错误. 如果错误为 EINTR 说明读是由中断引起的, 如果错误是 ECONNREST 表示网络连接出了问题.
+ read () 会把参数 fd 所指的文件传送 count 个字节到 buf 指针所指的内存中。若参数 count 为 0, 则 read () 不会有作用并返回 0. 返回值为实际读取到的字节数，如果返回 0, 表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动.错误代码：
  + EINTR 此调用被信号所中断.
  + EAGAIN 当使用不可阻断 I/O 时 (O_NONBLOCK), 若无数据可读取则返回此值.
  + EBADF 参数 fd 非有效的文件描述词，或该文件已关闭.

write 和 read 可以用send/recv替代。



#### send/recv函数

```c
#include <sys/socket.h>
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```

recv 和 send 的前 3 个参数等同于 read 和 write。flags 参数一般置为 0，或：

| flags         | 说明               | recv  | send |
| ------------- | ------------------ | ----- | ---- |
| MSG_DONTROUTE | 绕过路由表查找     |       | •    |
| MSG_DONTWAIT  | 仅本操作非阻塞     | **•** | •    |
| MSG_OOB       | 发送或接收带外数据 | •     | •    |
| MSG_PEEK      | 窥看外来消息       | •     |      |
| MSG_WAITALL   | 等待所有数据       | •     |      |

<font size=24, color=blue>Send</font>

同步 Socket 的 send 函数的执行流程：当调用该函数时，send先比较待发送数据的长度 len 和套接字 sockfd 的发送缓冲的长度（因为待发送数据是要 copy 到套接字 sockfd 的发送缓冲区的，注意并不是 send 把 sockfd 的发送缓冲中的数据传到连接的另一端的，而是协议传的，send 仅仅是把 buf 中的数据 copy到 sockfd 的发送缓冲区的剩余空间里）：

+ 如果 len 大于 sockfd 的发送缓冲区的长度，该函数返回SOCKET_ERROR；
+ 如果 len 小于或者等于 sockfd 的发送缓冲区的长度，那么send 先检查协议是否正在发送 sockfd 的发送缓冲中的数据，如果是就等待协议把数据发送完，如果协议还没有开始发送 sockfd 的发送缓冲中的数据或者 sockfd 的发送缓冲中没有数据，那么 send 就比较 sockfd 的发送缓冲区的剩余空间
  和 len：
  + 如果 len 大于剩余空间大小 send 就一直等待协议把 sockfd 的发送缓冲中的数据发送完；
  + 如果 len 小于剩余空间大小 send 就仅仅把 buf 中的数据 copy 到剩余空间里。

+ 如果 send 函数 copy 数据成功，就返回实际 copy 的字节数，如果 send 在 copy 数据时出现错误，那么 send 就返回SOCKET_ERROR；如果 send 在等待协议传送数据时网络断开的话，那么 send 函数也返回 SOCKET_ERROR。
+ send 函数把 buf 中的数据成功 copy 到 sockfd 的发送缓冲的剩余空间里后它就返回了，但是此时这些数据并不一定马上被传到连接的另一端。如果协议在后续的传送过程中出现网络错误的话，那么下一个 Socket 函数就会返回 SOCKET_ERROR。(每一个除 send 外的 Socket 函数在执行的最开始总要先等待套接字的发送缓冲中的数据被协议传送完毕才能继续，如果在等待时出现网络错误，那么该 Socket 函数就返回 SOCKET_ERROR）.
+ 在 unix 系统下，如果 send 在等待协议传送数据时网络断开，调用 send 的进程会接收到一个 SIGPIPE 信号，进程对该信号的处理是进程终止。

<font size=24, color=blue>recv</font>

```c
#include <sys/socket.h>
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
```



+ 同步 Socket 的 recv 函数的执行流程：当应用程序调用 recv 函数时，recv 先等待 sockfd 的发送缓冲中的数据被协议传送完毕;
+ 如果协议在传送 sockfd 的发送缓冲中的数据时出现网络错误，那么 recv 函数返回 SOCKET_ERROR；
+ 如果sockfd 的发送缓冲中没有数据或者数据被协议成功发送完毕后，recv 先检查套接字 sockfd 的接收缓冲区;
+ 如果 sockfd 接收缓冲区中没有数据或者协议正在接收数据，那么 recv 就一直等待，直到协议把数据接收完毕;
+ 当协议把数据接收完毕，recv 函数就把 sockfd 的接收缓冲中的数据 copy 到 buf 中（注意协议接收到的数据可能大于 buf 的长度，所以在这种情况下要调用几次 recv 函数才能把 sockfd 的接收缓冲中的数据 copy 完。recv 函数仅仅是 copy 数据，真正的接收数据是协议来完成的），recv 函数返回其实际 copy 的字节数;
+ 如果 recv 在 copy 时出错，那么它返回 SOCKET_ERROR；如果 recv 函数在等待协议接收数据时网络中断了，那么它返回0。

####  close函数

   ```
   #include <unistd.h>
   int close(sock_fd);
   ```

   <font color=blue>功能说明：</font>

   + 当所有的数据操作结束以后，你可以调用 close() 函数来释放该socket，从而停止在该 socket 上的任何数据操作，函数运行成功返回 0，否则返回-1;



####  示例

>
>实例1：
>
>```c
>//server.c
>#include <sys/types.h>
>#include <sys/socket.h>
>#include <stdio.h>
>#include <netinet/in.h>
>#include <arpa/inet.h>
>#include <unistd.h>
>#include <string.h>
>#include <stdlib.h>
>#include <fcntl.h>
>#include <sys/shm.h>
>
>#define MYPORT 8887
>#define QUEUE 20
>#define BUFFER_SIZE 1024
>
>int main()
>{
>///定义sockfd
>int server_sockfd = socket(AF_INET, SOCK_STREAM, 0);
>
>///定义sockaddr_in
>struct sockaddr_in server_sockaddr;
>server_sockaddr.sin_family = AF_INET;
>server_sockaddr.sin_port = htons(MYPORT);
>server_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY);
>
>///bind，成功返回0，出错返回-1
>if (bind(server_sockfd, (struct sockaddr *)&server_sockaddr, sizeof(server_sockaddr)) == -1)
>{
>perror("bind");
>exit(1);
>}
>
>///listen，成功返回0，出错返回-1
>if (listen(server_sockfd, QUEUE) == -1)
>{
>perror("listen");
>exit(1);
>}
>
>///客户端套接字
>char buffer[BUFFER_SIZE];
>struct sockaddr_in client_addr;
>socklen_t length = sizeof(client_addr);
>
>///成功返回非负描述字，出错返回-1
>int conn = accept(server_sockfd, (struct sockaddr *)&client_addr, &length);
>if (conn < 0)
>{
>perror("connect");
>exit(1);
>}
>
>while (1)
>{
>memset(buffer, 0, sizeof(buffer));
>int len = recv(conn, buffer, sizeof(buffer), 0);
>if (strcmp(buffer, "exit\n") == 0)
>   break;
>fputs(buffer, stdout);
>send(conn, buffer, len, 0);
>}
>close(conn);
>close(server_sockfd);
>return 0;
>}
>```
>
>```c
>//client.c
>#include <sys/types.h>
>#include <sys/socket.h>
>#include <stdio.h>
>#include <netinet/in.h>
>#include <arpa/inet.h>
>#include <unistd.h>
>#include <string.h>
>#include <stdlib.h>
>#include <fcntl.h>
>#include <sys/shm.h>
>
>#define MYPORT 8887
>#define BUFFER_SIZE 1024
>
>int main()
>{
>///定义sockfd
>int sock_cli = socket(AF_INET, SOCK_STREAM, 0);
>
>///定义sockaddr_in
>struct sockaddr_in servaddr;
>memset(&servaddr, 0, sizeof(servaddr));
>servaddr.sin_family = AF_INET;
>servaddr.sin_port = htons(MYPORT);                 ///服务器端口
>servaddr.sin_addr.s_addr = inet_addr("127.0.0.1"); ///服务器ip
>
>///连接服务器，成功返回0，错误返回-1
>if (connect(sock_cli, (struct sockaddr *)&servaddr, sizeof(servaddr)) < 0)
>{
>perror("connect");
>exit(1);
>}
>
>char sendbuf[BUFFER_SIZE];
>char recvbuf[BUFFER_SIZE];
>while (fgets(sendbuf, sizeof(sendbuf), stdin) != NULL)
>{
>send(sock_cli, sendbuf, strlen(sendbuf), 0); ///发送
>if (strcmp(sendbuf, "exit\n") == 0)
>   break;
>recv(sock_cli, recvbuf, sizeof(recvbuf), 0); ///接收
>fputs(recvbuf, stdout);
>
>memset(sendbuf, 0, sizeof(sendbuf));
>memset(recvbuf, 0, sizeof(recvbuf));
>}
>
>close(sock_cli);
>return 0;
>}
>```
>
>实例2
>
>```c
>//echo_server.c
>#include <stdio.h>
>#include <sys/socket.h>
>#include <arpa/inet.h>
>
>#define BUF_SIZE 5
>
>int main(int argc, char *argv[])
>{
>char message[BUF_SIZE];
>int str_len, i;
>
>struct sockaddr_in serv_addr, clnt_addr;
>
>int serv_sock = socket(PF_INET, SOCK_STREAM, 0);
>if (serv_sock == -1)
>{
>printf("socket() error");
>exit(1);
>}
>
>memset(&serv_addr, 0, sizeof(serv_addr));
>serv_addr.sin_family = AF_INET;
>serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);
>serv_addr.sin_port = htons(9600);
>
>if (bind(serv_sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) == -1)
>{
>printf("bind() error");
>exit(1);
>}
>
>if (listen(serv_sock, 5) == 1)
>{
>printf("listen() error");
>exit(1);
>}
>
>int clnt_addr_sz = sizeof(clnt_addr);
>for (i = 0; i < 5; i++)
>{
>int clnt_sock = accept(serv_sock, (struct sockaddr *)&clnt_addr, &clnt_addr_sz);
>if (clnt_sock == -1)
>{
>   printf("accept() error");
>   exit(1);
>}
>
>while (str_len = read(clnt_sock, message, BUF_SIZE) > 0)
>{
>   write(clnt_sock, message, str_len);
>}
>
>close(clnt_sock);
>}
>
>close(serv_sock);
>return 0;
>}
>```
>
>```c
>//echo_client.c
>#include <stdio.h>
>#include <string.h>
>#include <sys/socket.h>
>#include <arpa/inet.h>
>
>#define BUF_SIZE 5
>
>int main(int argc, char *argv[])
>{
>char message[BUF_SIZE];
>int str_len, i;
>
>struct sockaddr_in serv_addr, clnt_addr;
>
>int serv_sock = socket(PF_INET, SOCK_STREAM, 0);
>if (serv_sock == -1)
>{
>printf("socket() error");
>exit(1);
>}
>
>memset(&serv_addr, 0, sizeof(serv_addr));
>serv_addr.sin_family = AF_INET;
>serv_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
>serv_addr.sin_port = htons(9600);
>
>if (connect(serv_sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) == -1)
>{
>printf("connect() error");
>exit(1);
>}
>
>while (1)
>{
>fputs("请输入您的信息,按Q键退出\n", stdout);
>fgets(message, 1024, stdin);
>
>//因为fgets会保留输入中换行符,故判断加\n
>if (!strcmp(message, "q\n") || !strcmp(message, "Q\n"))
>{
>   break;
>}
>
>write(serv_sock, message, sizeof(message));
>read(serv_sock, message, BUF_SIZE - 1);
>printf("Message from server: %s\n", message);
>}
>
>close(serv_sock);
>return 0;
>}
>```
>
>



#### sendto / recvfrom函数

```c
#include < sys/types.h >
#include < sys/socket.h >
//定义函数
int sendto(int s , const void * msg, int len, unsigned int flags, const struct sockaddr * to , int tolen ) ;

```

   <font color=blue>功能说明：</font>

+ sendto () 用来将数据由指定的 socket 传给对方主机。参数 s 为已建好连线的 socket, 如果利用 UDP 协议则不需经过连线操作。参数 msg 指向欲连线的数据内容，参数 flags 一般设 0，详细描述请参考 send ()。参数 to 用来指定欲传送的网络地址，结构 sockaddr 请参考 bind ()。参数 tolen 为 sockaddr 的结果长度。

    <font color=blue>返回值：</font>

+ 成功则返回实际传送出去的字符数，失败返回－1，错误原因存于 errno 中。

   <font color=blue>errno错误代码：</font>

+  EBADF 参数 s 非法的 socket 处理代码。 
+ EFAULT 参数中有一指针指向无法存取的内存空间。 
+ WNOTSOCK canshu s 为一文件描述词，非socket。 
+ EINTR 被信号所中断。 
+ EAGAIN 此动作会令进程阻断，但参数 s 的 soket 为补课阻断的。 
+ ENOBUFS 系统的缓冲内存不足。
+  EINVAL 传给系统调用的参数不正确。

```c
#include < sys/types.h >
#include < sys/socket.h >
//定义函数
int recvfrom(int s,void *buf,int len,unsigned int flags ,struct sockaddr *from ,int *fromlen);
```

   <font color=blue>功能说明：</font>

+  recv () 用来接收远程主机经指定的 socket 传来的数据，并把数据存到由参数 buf 指向的内存空间，参数 len 为可接收数据的最大长度。参数 flags 一般设 0，其他数值定义请参考 recv ()。参数 from 用来指定欲传送的网络地址，结构 sockaddr 请参考 bind ()。参数 fromlen 为 sockaddr 的结构长度。

    <font color=blue>返回值：</font>

+  成功则返回接收到的字符数，失败则返回 - 1，错误原因存于 errno 中。

   <font color=blue>errno错误代码：</font>

+   EBADF 参数 s 非合法的 socket 处理代码;
+  EFAULT 参数中有一指针指向无法存取的内存空间。
+  ENOTSOCK 参数 s 为一文件描述词，非 socket。
+  EINTR 被信号所中断。 
+ EAGAIN 此动作会令进程阻断，但参数 s 的 socket 为不可阻断。 
+ ENOBUFS 系统的缓冲内存不足;
+ ENOMEM 核心内存不足 ；
+ EINVAL 传给系统调用的参数不正确。







> 实例
>
> ```c
> //server.c
> #include <sys/types.h>  
> #include <sys/socket.h>  
> #include <netinet/in.h>  
> #include <arpa/inet.h>  
> #include <unistd.h>  
> #include <stdlib.h>  
> #include <string.h>  
> #include <stdio.h>  
> #define PORT 1111 /* 使用的 port*/  
> main(){  
> int sockfd,len;  
> struct sockaddr_in addr;  
> int addr_len = sizeof(struct sockaddr_in);  
> char buffer[256];  
> /* 建立 socket*/  
> if((sockfd=socket(AF_INET,SOCK_DGRAM,0))<0){  
>   perror ("socket");  
>   exit(1);  
> }  
> /* 填写 sockaddr_in 结构 */  
> bzero ( &addr, sizeof(addr) );  
> addr.sin_family=AF_INET;  
> addr.sin_port=htons(PORT);  
> addr.sin_addr.s_addr=htonl(INADDR_ANY) ;  
> if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr))<0){  
>   perror("connect");  
>   exit(1);  
> }  
> while(1){  
>   bzero(buffer,sizeof(buffer));  
>   len = recvfrom(sockfd, buffer,sizeof(buffer), 0 , (struct sockaddr *)&addr ,&addr_len);  
>   /* 显示 client 端的网络地址 */  
>   printf("receive from %s\n" , inet_ntoa( addr.sin_addr));  
>   /* 将字串返回给 client 端 */  
>   sendto(sockfd,buffer,len,0,(struct sockaddr *)&addr,addr_len);  
> }  
> }  
> 
> 
> // client.c
> #include <sys/types.h>  
> #include <sys/socket.h>  
> #include <netinet/in.h>  
> #include <arpa/inet.h>  
> #include <unistd.h>  
> #include <stdlib.h>  
> #include <string.h>  
> #include <stdio.h>  
> #define PORT 1111  
> #define SERVER_IP "127.0.0.1"  
> main()  
> {  
> int s,len;  
> struct sockaddr_in addr;  
> int addr_len =sizeof(struct sockaddr_in);  
> char buffer[256];  
> /* 建立 socket*/  
> if((s = socket(AF_INET,SOCK_DGRAM,0))<0){  
>   perror("socket");  
>   exit(1);  
> }  
> /* 填写 sockaddr_in*/  
> bzero(&addr,sizeof(addr));  
> addr.sin_family = AF_INET;  
> addr.sin_port = htons(PORT);  
> addr.sin_addr.s_addr = inet_addr(SERVER_IP);  
> while(1){  
>   bzero(buffer,sizeof(buffer));  
>   /* 从标准输入设备取得字符串 */  
>   len =read(STDIN_FILENO,buffer,sizeof(buffer));  
>   /* 将字符串传送给 server 端 */  
>   sendto(s,buffer,len,0,(struct sockaddr *)&addr,addr_len);  
>   /* 接收 server 端返回的字符串 */  
>   len = recvfrom(s, buffer, sizeof(buffer), 0, (struct sockaddr *)&addr, &addr_len);  
>   printf("receive: %s",buffer);  
> }  
> }
> ```
>
> 





## setsockopt () 函数

```c
#include <sys/types.h>
#include <sys/socket.h>
int setsockopt (int sockfd, int level, int optname, const void * optval, ,socklen_toptlen);

struct in_addr
{
	in_addr_t s_addr;
};

struct ip_mreq
{
	struct in_addr imn_multiaddr; // 多播组 IP，类似于 QQ 群号
	struct in_addr imr_interface;   // 将要添加到多播组的 IP，类似于QQ 成员号
};
// 若进程要加入到一个组播组中，用 soket 的 setsockopt () 函数发送该选项。该选项类型是 ip_mreq 结构，它的第一个字段 imr_multiaddr 指定了组播组的地址，第二个字段 imr_interface 指定了接口的 IPv4 地址。
```

<font color=blue>功能说明：</font>

+ setsockopt () 用来设置参数 sockfd 所指定的 socket 状态。获取或者***设置***与某个套接字关联的选 项。选项可能存在于多层**协议***中，它们总会出现在最上面的套接字层。当操作套接字选项时，选项位于的层和选项的名称必须给出。为了操作套接字层的选项，应该 将层的值指定为SOL_SOCKET。为了操作其它层的选项，控制选项的合适协议号必须给出。例如，为了表示一个选项由 ***TCP*** 协议解析，层应该设定为协议 号 TCP 。

<font color=blue>参数说明：</font>

+ sockfd是套接字描述符,指向一个打开的套接口描述符。

+ 参数 level 是被设置的选项的级别，如果想要在套接字级别上设置选项，就必须把 level 设置为 SOL_SOCKET，它有以下选项：

  + SOL_SOCKET: 基本套接口，通用套接字选项。
  + IPPROTO_IP: IPv4 套接口
  + IPPROTO_IPV6: IPv6 套接口
  + IPPROTO_TCP: TCP 套接口

    一般设成 SOL_SOCKET 以存取 socket 层。

+ 参数 optname (选项名) 代表欲设置的选项的名称，option_name 可以有哪些取值，这取决于 level，下面会具体阐述：


+ 参数 optval (选项值) 代表欲设置的值；
+ 参数 optlen  (选项长度) 则为 optval 的长度.

返回值：成功则返回 0, 若有错误则返回 - 1, 错误原因存于 errno.

errno附加说明：

+ EBADF参数 sockfd 不是有效的**文件**描述词；
+ ENOTSOCK 参数 sockfd描述的不是套接字；
+ ENOPROTOOPT 参数 optname 指定的选项不正确，指定的协议层不能识别选项；
+ EFAULT 参数 optval 指针指向无法存取的内存空间，optval 指向的内存并非有效的进程 空间 ；

> 当level为SOL_SOCKET时，option_name 可以有以下取值：[见此处](https://www.cnblogs.com/cthon/p/9270778.html)
>   + SO_DEBUG 打开或关闭调试信息，当 option_value 不等于 0 时，打开调试信息，否则，关闭调试信息；+  SO_REUSEADDR 允许在 bind () 过程中本地地址可重复使用，打开或关闭地址复用功能，当 option_value 不等于 0 时，打开，否则，关闭；
>
> + SO_TYPE 返回 socket 形态；
>
>  + SO_ERROR 返回 socket 已发生的错误原因；
>
>  + SO_DONTROUTE 送出的数据包不要利用路由设备来传输；
>
>  + SO_BROADCAST 使用广播方式传送；
>
>  + SO_SNDBUF 设置发送缓冲区的大小；
>
>    + 在 send () 的时候，返回的是实际发送出去的字节 (同步) 或发送到 socket 缓冲区的字节(异步); 系统默认的状态发送和接收一次为8688 字节 (约为 8.5K)；在实际的过程中发送数据和接收数据量比较大，可以设置 socket 缓冲区，而避免了 send (),recv () 不断的循环收发：
>
>      ```c
>      // 接收缓冲区
>      int nRecvBuf=32*1024;// 设置为 32K
>      setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)&nRecvBuf,sizeof(int));
>      // 发送缓冲区
>      int nSendBuf=32*1024;// 设置为 32K
>      setsockopt(s,SOL_SOCKET,SO_SNDBUF,(const char*)&nSendBuf,sizeof(int));
>      //如果在发送数据的时，希望不经历由系统缓冲区到 socket 缓冲区的拷贝而影响程序的性能：
>      int nZero=0;
>      setsockopt(socket，SOL_S0CKET,SO_SNDBUF，(char *)&nZero,sizeof(nZero));
>                
>      //同上在 recv () 完成上述功能 (默认情况是将 socket 缓冲区的内容拷贝到系统缓冲区)：
>      int nZero=0;
>      setsockopt(socket，SOL_S0CKET,SO_RCVBUF，(char *)&nZero,sizeof(int));
>      ```
>
> 
>
>  + SO_RCVBUF 设置接收缓冲区的大小；
>
>  + SO_KEEPALIVE 定期确定连线是否已终止，套接字保活，如果协议是 TCP，并且当前的套接字状态不是侦听 (listen) 或关闭 (close)，那么，当 option_value 不是零时，启用 TCP 保活定时 器，否则关闭保活定时器；
>
>  + SO_OOBINLINE 当接收到 OOB 数据时会马上送至标准输入设备；
>
>  +  SO_LINGER 确保数据安全且可靠的传送出去；



> 当level为IPPROTO_IP时，option_name 可以有以下取值：
>
>   +  IP_ADD_MEMBERSHIP这个 option 和下面的 option 是实现多播必不可少的，它用于加入一个多播组，例：
>
>     ```c
>     struct ip_mreq ipmr;
>     ipmr.imr_interface.s_addr = htonl(INADDR_ANY);//本地某一网络设备接口的IP地址。
>     ipmr.imr_multiaddr.s_addr = inet_addr("234.5.6.7");//组播组的IP地址。
>     setsockopt(s, IPPROTO_IP, IP_ADDR_MEMBERSHIP, (char*)&ipmr, sizeof(ipmr));
>     ```
>
> 
>
>   +  IP_DROP_MEMBERSHIP 用于离开一个多播组，使用方法同 IP_ADDR_MEMBERSHIP:
>
>     ```c
>     struct ip_mreq ipmr;
>     int   len;
>     setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char*)&ipmr, &len);
>     ```
>
> 
>
> + IP_MULTICAST_IF 该选项可以修改网络接口，在结构 ip_mreq 中定义新的接口，发送多播报文时用的本地接口，默认情况下被设置成了本地接口的第一个地址；
>
> 
>
>  + IP_MULTICAST_TTL 设置组播报文的数据包的 TTL（生存时间）。默认值是 1，表示数据包只能在本地的子网中传送，默认情况下，多播报文的TTL被设置成了1，也就是说到这个报文在网络传送的时候，它只能在自己所在的网络传送，当要向外发送的时候，路由器把TTL减1以后变成了0，这个报文就已经被 Discard 了。例：
>
>    ```c
>    char ttl;
>    ttl = 2;
>    setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char*)ttl, sizeof(ttl));
>    ```
>
> 
>
>  + IP_MULTICAST_LOOP 组播组中的成员自己也会收到它向本组发送的报文。这个选项用于选择是否激活这种状态，当接收者加入到一个多播组以后，再向这个多播组发送数据，这个字段的设置是否允许再返回到本身；
>
>    ```c
>    int loop=1;    //1:on  0:off
>    setsockopt(sock,IPPROTO_IP,IP_MULTICAST_LOOP,&loop,sizeof(loop));
>    ```
>
> 



> 当level为IPPROTO_TCP时，option_name 可以有以下取值：
>
>   +  TCP_NODELAY 是唯一使用 IPPROTO_TCP 层的选项;
>   +  



## select函数

```c
#include<sys/time.h>
#include<sys/types.h>
#include<unistd.h>
int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout);
```

<font color=blue>先说明两个结构体：</font>

+ 第一，struct fd_set 可以理解为一个集合，这个集合中存放的是文件描述符 (filedescriptor)，即文件句柄，这可以是我们所说的普通意义的文件，当然 Unix 下任何设备、管道、FIFO 等都是文件形式，全部包括在内，所以毫无疑问一个 socket 就是一个文件，socket 句柄就是一个文件描述符。fd_set 集合可以通过一些宏由人为来操作，比如清空集合 FD_ZERO (fd_set *)，将一个给定的文件描述符加入集合之中 FD_SET (int ,fd_set*)，将一个给定的文件描述符从集合中删除 FD_CLR (int,fd_set*)，检查集合中指定的文件描述符是否可以读写 FD_ISSET (int ,fd_set* )。 
+ 第二，struct timeval 是一个大家常用的结构，用来代表时间值，有两个成员，一个是秒数，另一个是毫秒数。

<font color=blue>参数：</font>

+ int maxfdp 是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加 1，不能错！在 Windows 中这个参数的值无所谓，可以设置不正确。
+ fd_set * readfds 是指向 fd_set 结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的读变化的，即我们关心是否可以从这些文件中读取数据了，如果这个集合中有一个文件可读，select 就会返回一个大于 0 的值，表示有文件可读，如果没有可读的文件，则根据 timeout 参数再判断是否超时，若超出 timeout 的时间，select 返回 0，若发生错误返回负值。可以传入 NULL 值，表示不关心任何文件的读变化。
+ fd_set * writefds 是指向 fd_set 结构的指针，这个集合中应该包括文件描述符，我们是要监视这些文件描述符的写变化的，即我们关心是否可以向这些文件中写入数据了，如果这个集合中有一个文件可写，select 就会返回一个大于 0 的值，表示有文件可写，如果没有可写的文件，则根据 timeout 参数再判断是否超时，若超出 timeout 的时间，select 返回 0，若发生错误返回负值。可以传入 NULL 值，表示不关心任何文件的写变化。
+ fd_set * errorfds 同上面两个参数的意图，用来监视文件错误异常。
+ struct timeval * timeout 是 select 的超时时间，这个参数至关重要，它可以使 select 处于三种状态，第一，若将 NULL 以形参传入，即不传入时间结构，就是将 select 置于阻塞状态，一定等到监视文件描述符集合中某个文件描述符发生变化为止；第二，若将时间值设为 0 秒 0 毫秒，就变成一个纯粹的非阻塞函数，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回 0，有变化返回一个正值；第三，timeout 的值大于 0，这就是等待的超时时间，即 select 在 timeout 时间内阻塞，超时时间之内有事件到来就返回了，否则在超时后不管怎样一定返回，返回值同上述。

<font color=blue>返回值：</font>**返回值：返回状态发生变化的描述符总数。**

+ 负值：select 错误；

+ 正值：某些文件可读写或出错；

+ 0：等待超时，没有可读写或错误的文件；



> 实例1
>
> ```c
> #include <sys/types.h>
> #include <sys/time.h>
> #include <stdio.h>
> #include <fcntl.h>
> #include <sys/ioctl.h>
> #include <unistd.h>
> 
> int main()
> {
> char buffer[128];
> int result, nread;
> fd_set inputs, testfds;
> struct timeval timeout;
> FD_ZERO(&inputs);   //用select函数之前先把集合清零
> FD_SET(0, &inputs); //把要检测的句柄——标准输入（0），加入到集合里。
> while (1)
> {
>   testfds = inputs;
>   timeout.tv_sec = 2;
>   timeout.tv_usec = 500000;
>   result = select(FD_SETSIZE, &testfds, (fd_set *)0, (fd_set *)0, &timeout);
>   switch (result)
>   {
>   case 0:
>       printf("timeout/n");
>       break;
>   case -1:
>       perror("select");
>       exit(1);
>   default:
>       if (FD_ISSET(0, &testfds))
>       {
>           ioctl(0, FIONREAD, &nread); //取得从键盘输入字符的个数，包括回车。
>           if (nread == 0)
>           {
>               printf("keyboard done/n");
>               exit(0);
>           }
>           nread = read(0, buffer, nread);
>           buffer[nread] = 0;
>           printf("read %d from keyboard: %s", nread, buffer);
>       }
>       break;
>   }
> }
> return 0;
> }
> ```
>
> 实例2
>
> ```c
> //server.c
> 
> 
> //client.c
> 
> 
> 
> ```
>
> 



## gethostbyname函数

域名仅仅是 IP 地址的一个助记符，目的是方便记忆，通过域名并不能找到目标计算机，通信之前必须要将域名转换成 IP 地址。

gethostbyname () 函数可以完成这种转换，它的原型为：

```c
struct hostent *gethostbyname(const char *hostname);
```

hostname 为主机名，也就是域名。使用该函数时，只要传递域名字符串，就会返回域名对应的 IP 地址。返回的地址信息会装入hostent 结构体，该结构体的定义如下：

```c
struct hostent{
    char *h_name;  //official name
    char **h_aliases;  //alias list
    int  h_addrtype;  //host address type
    int  h_length;  //address lenght
    char **h_addr_list;  //address list
}
```

从该结构体可以看出，不只返回 IP 地址，还会附带其他信息，各位读者只需关注最后一个成员 h_addr_list。下面是对各成员的说明：

- h_name：官方域名（Official domain name）。官方域名代表某一主页，但实际上一些著名公司的域名并未用官方域名注册。
- h_aliases：别名，可以通过多个域名访问同一主机。同一 IP 地址可以绑定多个域名，因此除了当前域名还可以指定其他域名。
- h_addrtype：gethostbyname () 不仅支持 IPv4，还支持 IPv6，可以通过此成员获取 IP 地址的地址族（地址类型）信息，IPv4 对应 AF_INET，IPv6 对应 AF_INET6。
- h_length：保存 IP 地址长度。IPv4 的长度为 4 个字节，IPv6 的长度为 16 个字节。
- h_addr_list：这是最重要的成员。通过该成员以整数形式保存域名对应的 IP 地址。对于用户较多的服务器，可能会分配多个 IP 地址给同一域名，利用多个服务器进行均衡负载。


hostent 结构体变量的组成如下图所示：

![hostent 结构体的组成](http://c.biancheng.net/uploads/allimg/190219/135F5L39-0.jpg)


下面的代码主要演示 gethostbyname () 的应用，并说明 hostent 结构体的特性：

```c
#include <stdio.h>
#include <stdlib.h>
#include <float.h>
#include <limits.h>
#include <math.h>
#include <string.h>
#include <sys/socket.h>
#include <stddef.h>
#include <locale.h>
#include <time.h>
#include <complex.h>
#include <netdb.h>
#include <arpa/inet.h>

int main(int argc, char *argv[])
{
    struct hostent *host;

    host = gethostbyname("www.baidu.com");

    // 主机的规范名
    printf("h_name=%s\n", host->h_name);

    //别名
    for (int i = 0; host->h_aliases[i]; i++)
    {
        printf("Aliases %d: %s\n", i + 1, host->h_aliases[i]);
    }

    //IP地址类型
    printf("Address type: %s\n", (host->h_addrtype == AF_INET) ? "AF_INET" : "AF_INET6");
    printf("addrtype=%d\n", host->h_addrtype);

    // IP 地址
    for (int i = 0; host->h_addr_list[i]; i++)
    {
        //将IP指针转换为 in_addr 结构体, 再调用inet_ntoa转换为字符串形式
        printf("Ip addr: %s\n", inet_ntoa(*(struct in_addr *)host->h_addr_list[i]));
    }
}

```

```c
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>

extern int h_errno;

int main(int argc, char **argv)
{
    if (argc != 2)
    {
        printf("Use example: %s www.google.com\n", *argv);
        return -1;
    }

    char *name = argv[1];
    struct hostent *hptr;

    hptr = gethostbyname(name);
    if (hptr == NULL)
    {
        printf("gethostbyname error for host: %s: %s\n", name, hstrerror(h_errno));
        return -1;
    }
    //输出主机的规范名
    printf("\tofficial: %s\n", hptr->h_name);

    //输出主机的别名
    char **pptr;
    char str[INET_ADDRSTRLEN];
    for (pptr = hptr->h_aliases; *pptr != NULL; pptr++)
    {
        printf("\ttalias: %s\n", *pptr);
    }

    //输出ip地址
    switch (hptr->h_addrtype)
    {
    case AF_INET:
        pptr = hptr->h_addr_list;
        for (; *pptr != NULL; pptr++)
        {
            printf("\taddress: %s\n",
                   inet_ntop(hptr->h_addrtype, hptr->h_addr, str, sizeof(str)));
        }
        break;
    default:
        printf("unknown address type\n");
        break;
    }

    return 0;
}
```

