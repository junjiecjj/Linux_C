/*************************************************************************
>> File Name: 计数排序.c
>> Author: chenjunjie
>> Mail: 2716705056qq.com
>> Created Time: 2019.01.21

计数排序用到一个额外的计数数组 C，根据数组 C 来将原数组 A 中的元素排到正确的位置。

通俗地理解，例如有 10 个年龄不同的人，假如统计出有 8 个人的年龄不比小明大（即小于等于小明的年龄，这里也包括了小明），那么小明的年龄就排在第 8 位，通过这种思想可以确定每个人的位置，也就排好了序。当然，年龄一样时需要特殊处理（保证稳定性）：通过反向填充目标数组，填充完毕后将对应的数字统计递减，可以确保计数排序的稳定性。

计数排序的步骤如下：

统计数组 A 中每个值 A [i] 出现的次数，存入 C [A [i]]

从前向后，使数组 C 中的每个值等于其与前一项相加，这样数组 C [A [i]] 就变成了代表数组 A 中小于等于 A [i] 的元素个数

反向填充目标数组 B：将数组元素 A [i] 放在数组 B 的第 C [A [i]] 个位置（下标为 C [A [i]] – 1），每放一个元素就将 C [A [i]] 递减.

计数排序的时间复杂度和空间复杂度与数组 A 的数据范围（A 中元素的最大值与最小值的差加上 1）有关，因此对于数据范围很大的数组，计数排序需要大量时间和内存。

例如：对 0 到 99 之间的数字进行排序，计数排序是最好的算法，然而计数排序并不适合按字母顺序排序人名，将计数排序用在基数排序算法中，能够更有效的排序数据范围很大的数组。
计数排序的实现代码如下：
************************************************************************/
// 分类 ------------ 内部非比较排序
// 数据结构 --------- 数组
// 最差时间复杂度 ---- O (n + k)
// 最优时间复杂度 ---- O (n + k)
// 平均时间复杂度 ---- O (n + k)
// 所需辅助空间 ------ O (n + k)
// 稳定性 ----------- 稳定
#include <stdio.h>
#include <stdlib.h>

const int K = 100;

void CountingSort(int A[], int n)
{
    int *C = (int *)malloc(K * sizeof(int));
    for (int i = 0; i < K; i++)
        C[i] = 0;

    for (int i = 0; i < n; i++)
        C[A[i]]++;

    for (int i = 1; i < K; i++)
        C[i] = C[i] + C[i - 1];

    int *B = (int *)malloc(n * sizeof(int));

    for (int i = n - 1; i >= 0; i--)
        B[--C[A[i]]] = A[i];

    for (int i = 0; i < n; i++)
        A[i] = B[i];

    free(B);
}

int main(int argc, char *argv[])
{
    int A[] = {15, 22, 19, 46, 27, 73, 1, 19, 8}; // 针对计数排序设计的输入，每一个元素都在[0,100]上且有重复元素
    int n = sizeof(A) / sizeof(int);
    CountingSort(A, n);
    printf("计数排序结果：");
    for (int i = 0; i < n; i++)
    {
        printf("%d ", A[i]);
    }
    printf("\n");
    return 0;
}
