/*************************************************************************
>> File Name: test.cpp
>> Author: 陈俊杰
>> Mail: 2716705056qq.com

>> Created Time: 2021年06月27日 星期日 00时49分15秒

>> 此程序的功能是：
https://www.runoob.com/w3cnote/cpp-static-const.html
************************************************************************/


#ifndef _DEFINE_CJJ
#define _DEFINE_CJJ


#include<iostream>
using namespace std;
#include<bits/stdc++.h>
#include<cstdio>
#include<ctime>
#include<string>
#include<clocale>
#include<vector>





/*****************************************************************************
 * 类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。
 * 在类体中和类体外定义成员函数的区别
 * 在类体中和类体外定义成员函数是有区别的：在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。当然，在类体内部定义的函数也可以加 inline 关键字，但这是多余的，因为类体内部定义的函数默认就是内联函数。
 * 内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。
 *  这种在类体外定义 inline 函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入（将函数代码的嵌入到函数调用出），
 * 成员变量大都以m_开头，这是约定成俗的写法，不是语法规定的内容。以m_开头既可以一眼看出这是成员变量，又可以和成员函数中的形参名字区分开。
 * 给成员变量赋值的函数通常称为 set 函数，它们的名字通常以set开头，后跟成员变量的名字；读取成员变量的值的函数通常称为 get 函数，它们的名字通常以get开头，后跟成员变量的名字。






(一)测试静态成员变量和静态成员函数


1.静态成员变量

静态成员变量是一种特殊的成员变量，类体中的数据成员声明时前面加上关键字static，即成为该类的静态数据成员，即静态成员变量。静态成员变量实际上就是类域中的全局变量，必须初始化，且只能在类体外。初始化时不受private和protected访问限制。

- 静态成员变量属于类，不属于某个具体的对象。如上面的代码，即使创建多个对象，也只为num分配一份内存，所有对象使用的是这份内存中的数据，当某个对象修改了num，也会影响到其他的对象。static成员变量不占用对象内存，在所有对象外开辟内存，不创建对象也可以访问。
- static成员变量和普通static变量一样，编译时在静态数据区分配内存，到程序结束时才释放。这就意味着static成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。
- static成员变量初始化不赋值会被默认初始化，一般是 0。静态数据区的变量都有默认的初始值，而动态数据区（堆区、栈区）的变量默认是垃圾值。

静态成员变量可以成为成员函数的可选参数，而普通成员变量不可以。

静态成员变量的类型可以是所属类的类型，但是普通成员变量不行。普通成员只能声明为所属类类型的指针或引用。

静态成员变量
    -静态成员变量属于整个类所有
    -静态成员变量的生命期不依赖于任何对象，为程序的生命周期
    -可以通过类名直接访问公有静态成员变量
    -所有对象共享类的静态成员变量
    -可以通过对象名访问公有静态成员变量
    -静态成员变量需要在类外单独分配空间
    -静态成员变量在程序内部位于全局数据区 (Type className::VarName = value)

这表明：

(1) 初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆。
(2) 初始化时不加该成员的访问权限控制符private，public等。
(3) 初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员。
3、静态数据成员是静态存储的，它是静态生存期，必须对它进行初始化。

在C++中，我们可以使用静态成员变量来实现多个对象共享数据的目标。静态成员变量是一种特殊的成员变量，它被关键字static修饰，例如：
//  static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 static 成员变量 分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了 static 成员变量，也会影响到其他对象。
// static 成员变量必须在类声明的外部初始化.
// 静态成员变量在初始化时不能再加 static，但必须要有数据类型。被 private、protected、public 修饰的静态成员变量都可以用这种方式初始化。
// 注意：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。
// 注意：static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存。
//  static 成员变量既可以通过对象来访问，也可以通过类来访问
// 1) 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。
//  2) static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。
// 3) 静态成员变量必须初始化，而且只能在类体外进行。例如： int Student::m_total = 10;
// 初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。
// 4) 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。


2.静态成员函数

静态成员函数有如下特性:
    -静态成员函数是类的一个特殊的成员函数
    -静态成员函数属于整个类所有，没有this指针
    -静态成员函数只能直接访问静态成员变量和静态成员函数
    -可以通过类名直接访问类的公有静态成员函数
    -可以通过对象名访问类的公有静态成员函数
    -定义静态成员函数，直接使用static关键字修饰即可
注意下面几点：

普通成员函数可以访问所有成员变量，而静态成员函数只能访问静态成员变量。

调用一个对象的非静态成员函数时，系统会把当前对象的起始地址赋给 this 指针。而静态成员函数并不属于某一对象，它与任何对象都无关，因此静态成员函数没有 this 指针。

静态成员函数与非静态成员函数的根本区别是：有无this指针。由此决定了静态成员函数不能访问本类中的非静态成员。

如果类的成员函数想作为回调函数来使用，一般情况下只能将它定义为静态成员才行。

在类中，static 除了可以声明静态成员变量，还可以声明静态成员函数。普通成员函数可以访问所有成员（包括成员变量和成员函数），静态成员函数只能访问静态成员。

编译器在编译一个普通成员函数时，会隐式地增加一个形参 this，并把当前对象的地址赋值给 this，所以普通成员函数只能在创建对象后通过对象来调用，因为它需要当前对象的地址。而静态成员函数可以通过类来直接调用，编译器不会为它增加形参 this，它不需要当前对象的地址，所以不管有没有创建对象，都可以调用静态成员函数。

普通成员变量占用对象的内存，静态成员函数没有 this 指针，不知道指向哪个对象，无法访问对象的成员变量，也就是说静态成员函数不能访问普通成员变量，只能访问静态成员变量。

普通成员函数必须通过对象才能调用，而静态成员函数没有 this 指针，无法在函数体内部访问某个对象，所以不能调用普通成员函数，只能调用静态成员函数。

静态成员函数与普通成员函数的根本区别在于：普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。

3. static const 类型成员变量:
    const 定义的常量在超出其作用域之后其空间会被释放，而 static 定义的静态常量在函数执行后不会释放其存储空间。

    static 表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。

    在 C++ 中，static 静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化，如：double Account::Rate = 2.25;

    static 关键字只能用于类定义体内部的声明中，定义时不能标示为 static。

    在 C++ 中，const 成员变量也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。

    const 数据成员 只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其 const 数据成员的值可以不同。所以不能在类的声明中初始化 const 数据成员，因为类的对象没被创建时，编译器不知道 const 数据成员的值是什么。

    const 数据成员的初始化只能在类的构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static cosnt。

*****************************************************************************/



/*****************************************************************************
定义某个类 A
*****************************************************************************/
class A{
    public:
        A(int a);
        static void printaa();//静态成员函数
        void  printbb();
    private:
        static int aa;//静态数据成员的声明
        static const int count;//常量静态数据成员（可以在构造函数中初始化）
        const int bb;//常量数据成员
};



/*****************************************************************************
定义某个类 Student
*****************************************************************************/



class Student{
    public:
        Student(char *name, int age, float score);
        void show(void);
        void setAge(int age);
        void showRealAge(void);
        int realAge;

    private:
        static int m_total;  //静态成员变量

    private:
        char *m_name;
        int m_age;
        float m_score;
};



/*****************************************************************************
定义某个类 Stamp
*****************************************************************************/

//返回北京时间
void GetTimeOfNow(char * G);

class Stamp{
    private:
        char value[128];
        static const vector<string> Wday;//  = {"Sun","Mon","Tue","Wed","Thu","Fri","Sat"};
        static const int AA = 12; //正确，静态常量成员可以直接初始化，也可以在.cpp文件中初始化

    public:
        Stamp();
        virtual  ~Stamp();
        void  ShowWday(void);
        void  ShowAA(void);
        const char* GetStartTime(void) const;
};



/*****************************************************************************
(二)   测试public, private, protected
一般地，在类的内部，无论成员被声明为哪种，都是可以互相访问的；但在类的外部，如通过类的对象，则只能访问 public 属性的成员，不能访问protected、private属性的成员。
public：可以被该类中的函数、子类的函数、友元函数访问，也可以由该类的对象访问；
protected：可以被该类中的函数、子类的函数、友元函数访问，但不可以由该类的对象访问；
private：可以被该类中的函数、友元函数访问，但不可以由子类的函数、该类的对象、访问。

private：用来指定私有成员。一个类的私有成员，不论是成员变量还是成员函数，都只能在该类的成员函数内部才能被访问。

public：用来指定公有成员。一个类的公有成员在任何地方都可以被访问。

protected：用来指定保护成员。这需要等介绍“继承”之后再解释。

三种关键字出现的次数和先后次序都没有限制。成员变量的可访问范围由离它前面最近的那个访问范围说明符决定。

如果某个成员前面没有访问范围说明符，则对 class 来说，该成员默认地被认为是私有成员；对 struct 来说，该成员默认地被认为是公有成员。

注意事项
如果声明不写 public、protected、private，则默认为 private；
声明public、protected、private的顺序可以任意；
在一个类中，public、protected、private 可以出现多次，每个限定符的有效范围到出现另一个限定符或类结束为止。但为了使程序清晰，应该使每种限定符只出现一次。



(三)   const成员函数（常成员函数）:
    //  const 成员函数可以使用类中的所有成员变量，但是不能修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。
    // 我们通常将 get 函数设置为常成员函数。读取成员变量的函数的名字通常以get开头，后跟成员变量的名字，所以通常将它们称为 get 函数。
    // 常成员函数需要在声明和定义的时候在函数头部的结尾加上 const 关键字，
    // 最后再来区分一下 const 的位置：
    // 函数开头的 const 用来修饰函数的返回值，表示返回值是 const 类型，也就是不能被修改，例如const char * getname()。
    //  函数头部的结尾加上 const 表示常成员函数，这种函数只能读取成员变量的值，而不能修改成员变量的值，例如char * getname() const。

    const 成员变量：
        构造函数初始化列表还有一个很重要的作用，那就是初始化 const 成员变量。初始化 const 成员变量的唯一方法就是使用初始化列表。



(四)   构造函数/析构函数:
 * 1 在C++中，有一种特殊的成员函数，它的名字和类名相同，没有返回值，不需要用户显式调用（用户也不能调用），而是在创建对象时自动执行。这种特殊的成员函数就是构造函数（Constructor）。
 * 2 构造函数必须是 public 属性的，否则创建对象时无法调用。当然，设置为 private、protected 属性也不会报错，但是没有意义。
 * 3 构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处，这意味着：
 *    不管是声明还是定义，函数名前面都不能出现返回值类型，即使是 void 也不允许；
 *     函数体中不能有 return 语句。
 * 4 构造函数的重载:
 *    和普通成员函数一样，构造函数是允许重载的。一个类可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪一个构造函数。
 *      构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。
如果用户自己没有定义构造函数，那么编译器会自动生成一个默认的构造函数，只是这个构造函数的函数体是空的，也没有形参，也不执行任何操作。比如上面的 Student 类，默认生成的构造函数如下：
Student(){}
一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。在示例1中，Student 类已经有了一个构造函数Student(char *, int, float)，也就是我们自己定义的，编译器不会再额外添加构造函数Student()，在示例2中我们才手动添加了该构造函数。
实际上编译器只有在必要的时候才会生成默认构造函数，而且它的函数体一般不为空。默认构造函数的目的是帮助编译器做初始化工作，而不是帮助程序员。这是C++的内部实现机制，这里不再深究，初学者可以按照上面说的“一定有一个空函数体的默认构造函数”来理解。
最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。对于示例2的代码，在栈上创建对象可以写作Student stu()或Student stu，在堆上创建对象可以写作Student *pstu = new Student()或Student *pstu = new Student，它们都会调用构造函数 Student()。

以前我们就是这样做的，创建对象时都没有写括号，其实是调用了默认的构造函数。
构造函数的一项重要功能是对成员变量进行初始化，为了达到这个目的，可以在构造函数的函数体中对成员变量一一赋值，还可以采用初始化列表。
使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。
注意，成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。



析构函数:
创建对象时系统会自动调用构造函数进行初始化工作，同样，销毁对象时系统也会自动调用一个函数来进行清理工作，例如释放分配的内存、关闭打开的文件等，这个函数就是析构函数。
析构函数（Destructor）也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个~符号。

注意：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。
C++ 中的 new 和 delete 分别用来分配和释放内存，它们与C语言中 malloc()、free() 最大的一个不同之处在于：用 new 分配内存时会调用构造函数，用 delete 释放内存时会调用析构函数。构造函数和析构函数对于类来说是不可或缺的，所以在C++中我们非常鼓励使用 new 和 delete。

在所有函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。

在函数内部创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。

new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。


(五) this指针
几点注意：
this 是 const 指针，它的值是不能被修改的，一切企图修改该指针的操作，如赋值、递增、递减等都是不允许的。
this 只能在成员函数内部使用，用在其他地方没有意义，也是非法的。
只有当对象被创建后 this 才有意义，因此不能在 static 成员函数中使用（后续会讲到 static 成员）。


(六)C++ const对象（常对象）
在 C++ 中，const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）了。

定义常对象的语法和定义常量的语法类似：
const  class  object(params);
class const object(params);

当然你也可以定义 const 指针：
const class *p = new class(params);
class const *p = new class(params);

class为类名，object为对象名，params为实参列表，p为指针名。两种方式定义出来的对象都是常对象。
如果你对 const 的用法不理解，请猛击《C语言const的用法详解》。
一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。


(七) C++ class和struct到底有什么区别
C++ 中保留了C语言的 struct 关键字，并且加以扩充。在C语言中，struct 只能包含成员变量，不能包含成员函数。而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。

C++中的 struct 和 class 基本是通用的，唯有几个细节不同：
使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
class 继承默认是 private 继承，而 struct 继承默认是 public 继承（《C++继承与派生》一章会讲解继承）。
class 可以使用模板，而 struct 不能（《模板、字符串和异常》一章会讲解模板）。

C++ 没有抛弃C语言中的 struct 关键字，其意义就在于给C语言程序开发人员有一个归属感，并且能让C++编译器兼容以前用C语言开发出来的项目。

在编写C++代码时，我强烈建议使用 class 来定义类，而使用 struct 来定义结构体，这样做语义更加明确。

*****************************************************************************/



class CEmployee {
private:
    float m_Salary;  //工资
    int m_Age;       //年纪
    float m_Score;   // 成绩

	int *m_arr_point;  //数组的首地址
	int m_arr_len;

    //  const 成员变量,初始化 const 成员变量的唯一方法就是使用初始化列表。
    const int m_len;
    int *m_arr;
    int *m_p;  //指向数组第i个元素的指针

private:
    // 静态成员变量
    static int m_total;  //总人数
    static float m_points;  //总成绩

private:
    int *at(int i);  //获取第i个元素的指针

public:
    char m_szName[30];  //字符数组创建，名字
    char* m_name;        // 字符指针创建，名字
    bool m_flag;  //定义布尔变量，在定义类的时候不能对成员变量赋值，因为类只是一种数据类型或者说是一种模板，本身不占用内存空间，而变量的值则需要内存来存储。

public:  //声明静态成员函数
    static int getTotal();
    static float getPoints();
    // 总人数 m_total 和总成绩 m_points 由各个对象累加得到，必须声明为 static 才能共享；getTotal()、getPoints() 分别用来获取总人数和总成绩，为了访问 static 成员变量，我们将这两个函数也声明为 static。
    // 在C++中，静态成员函数的主要目的是访问静态成员。getTotal()、getPoints() 当然也可以声明为普通成员函数，但是它们都只对静态成员进行操作，加上 static 语义更加明确。
    //  和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static。静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用，上例仅仅演示了如何通过类来调用。

public:
    //声明构造函数
    // 默认构造函数
    CEmployee(float score, int len);
    //采用初始化列表
    CEmployee(char *szname, int age, float salary, float score, int len);
    //构造函数的重载
    CEmployee(const char  *szname, const char* nm, int age, float salary, float score, int arr[], int arrlen,int len);

    void input();  //从控制台输入数组元素
    void show();  //显示数组元素

    virtual  ~CEmployee();

    void setName(const char* name);
    // const成员函数（常成员函数）:
    void getName(char* name)  const;

    void setAge(int age);
    int getAge(void)  const;

    void setSalary(float salary);
    float getSalary(void)   const;

    void setScore(float score);
    float getScore(void)   const;

    void ShowEmployee(void);
    void averageSalary(CEmployee el, CEmployee e2);

    void showArray() const;



};




#endif // _TIME_CJJ